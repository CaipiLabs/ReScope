{"version":3,"sources":["webpack:///dist/Rescope.nodeps.min.js","webpack:///webpack/bootstrap 187e76790ed17b86fce4","webpack:///./src/Rescope.js","webpack:///external \"is\"","webpack:///./src/Emitter.js","webpack:///./src/Scope.js","webpack:///external \"shortid\"","webpack:///./src/Store.js"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_defineProperty","key","value","Object","defineProperty","enumerable","configurable","writable","_Scope","_Scope2","_Store","_Store2","Store","Scope","require","_toConsumableArray","arr","Array","isArray","i","arr2","length","from","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","descriptor","protoProps","staticProps","prototype","is","Emitter","this","_events","evt","cb","_this","string","keys","forEach","k","on","push","_this2","un","indexOf","splice","lists","_len","arguments","argz","_key","apply","_this3","fn","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","EventEmitter","shortid","__proto__push","parent","openScopes","_EventEmitter","storesMap","_ref","undefined","state","data","incrementId","name","defaultMaxListeners","persistenceTm","autoDestroy","rootEmitter","getPrototypeOf","_maxListeners","generate","_ret","_id","register","_isLocalId","_persistenceTm","stores","dead","Error","sources","_childScopes","_childScopesList","_unStableChilds","__retains","all","__locks","__listening","__scope","__mixed","__mixedList","_followers","retain","__parentList","update","s","_propag","_stable","wait","stable","release","unstable","_addChild","setTimeout","tm","dispose","scopes","skey","array","sort","a","b","firstname","join","storesList","_mount","store","_parent","reduce","mounted","ctx","setState","_watchStore","_parent2","isStable","destroy","propag","targetCtx","_this4","relink","_this5","singleton","srcCtx","_this6","external","force","lctx","_stores","get","_state","set","v","_data","as","setInitial","lastRevs","reKey","map","revs","mount","getUpdates","followers","to","_this7","bind","mixedCWUnmount","unMountKey","isReactComponent","hasOwnProperty","unBind","split","retrieve","path","storesRevMap","local","_rev","updated","getStoresRevs","output","_this8","_this9","flags_states","flags_data","flags","r","flag","test","action","_this10","trigger","dispatch","_this11","once","e","_ref2","quiet","_this12","reason","_this13","emit","_this14","_stabilizerTM","clearTimeout","_propagTM","_this15","_this16","_ref3","_this17","stableTree","unstableTree","wasStable","_this18","_destroyTM","then","_this19","removeListener","shift","_rmChild","scope","_extends","assign","source","_get","object","property","receiver","Function","desc","getOwnPropertyDescriptor","getter","objProto","_this$_require","_this$_require2","applied","_static","getScope","staticScope","cfg","watchs","use","initialState","_uid","_onStabilize","scopeObj","_revs","_require","_use","concat","ref","match","ref2","shouldApply","managed","nDatas","cDatas","isComplete","follow","changes","refine","_stabilizer","_scopeObj","actions","ns","_actions$action","_len2","_key2","doWait","origin","initialOutputs","nextState","_changesSW","nextDatas","shouldPropag","pState","sync","change","stabilize","pull","previous","follower","rev","removeAllListeners","component","targetRevs","targetScope","filter","alias","defaultName","slice"],"mappings":"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","file":"dist/Rescope.nodeps.min.js","sourcesContent":["/*!\n * MIT License\r\n * \r\n * Copyright (c) 2018 Wise Wild Web\r\n * \r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n * \r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n * \r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\n */\nmodule.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _Scope = __webpack_require__(3);\n\t\n\tvar _Scope2 = _interopRequireDefault(_Scope);\n\t\n\tvar _Store = __webpack_require__(5);\n\t\n\tvar _Store2 = _interopRequireDefault(_Store);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; } /*\n\t                                                                                                                                                                                                                   * Copyright (c) 2018.  Caipi Labs.  All rights reserved.\n\t                                                                                                                                                                                                                   *\n\t                                                                                                                                                                                                                   * This File is part of Caipi. You can redistribute it and/or modify\n\t                                                                                                                                                                                                                   * it under the terms of the GNU Affero General Public License as\n\t                                                                                                                                                                                                                   * published by the Free Software Foundation, either version 3 of the\n\t                                                                                                                                                                                                                   * License, or (at your option) any later version.\n\t                                                                                                                                                                                                                   * This program is distributed in the hope that it will be useful,\n\t                                                                                                                                                                                                                   * but WITHOUT ANY WARRANTY; without even the implied warranty of\n\t                                                                                                                                                                                                                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\t                                                                                                                                                                                                                   * GNU Affero General Public License for more details.\n\t                                                                                                                                                                                                                   * You should have received a copy of the GNU Affero General Public License\n\t                                                                                                                                                                                                                   * along with this program. If not, see <http://www.gnu.org/licenses/>.\n\t                                                                                                                                                                                                                   *  This project is dual licensed under AGPL and Commercial Licence.\n\t                                                                                                                                                                                                                   *\n\t                                                                                                                                                                                                                   * @author : Nathanael Braun\n\t                                                                                                                                                                                                                   * @contact : caipilabs@gmail.com\n\t                                                                                                                                                                                                                   */\n\t\n\t_Scope2.default.Store = _Store2.default;\n\t\n\texports.default = _defineProperty({ Store: _Store2.default, Scope: _Scope2.default }, \"Scope\", _Scope2.default);\n\tmodule.exports = exports[\"default\"];\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"is\");\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/*\n\t * Copyright (c)  2017 Caipi Labs .\n\t *\n\t * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\t *\n\t * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\t *\n\t * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t *\n\t * @author : Nathanael Braun\n\t * @contact : caipilabs@gmail.com\n\t */\n\tvar is = __webpack_require__(1);\n\t\n\tvar Emitter = function () {\n\t    function Emitter() {\n\t        _classCallCheck(this, Emitter);\n\t\n\t        this._events = {};\n\t    }\n\t\n\t    _createClass(Emitter, [{\n\t        key: 'on',\n\t        value: function on(evt, cb) {\n\t            var _this = this;\n\t\n\t            if (!is.string(evt) && evt) return Object.keys(evt).forEach(function (k) {\n\t                return _this.on(k, evt[k]);\n\t            });\n\t\n\t            this._events[evt] = this._events[evt] || [];\n\t            this._events[evt].push(cb);\n\t        }\n\t    }, {\n\t        key: 'un',\n\t        value: function un(evt, cb) {\n\t            var _this2 = this;\n\t\n\t            if (!is.string(evt) && evt) return Object.keys(evt).forEach(function (k) {\n\t                return _this2.un(k, evt[k]);\n\t            });\n\t\n\t            if (!this._events[evt]) return;\n\t            var i = this._events[evt].indexOf(cb);\n\t            this._events[evt].splice(i, 1);\n\t        }\n\t    }, {\n\t        key: 'emit',\n\t        value: function emit(evt) {\n\t            if (!this._events[evt]) return;\n\t            var lists = [].concat(_toConsumableArray(this._events[evt]));\n\t\n\t            for (var _len = arguments.length, argz = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t                argz[_key - 1] = arguments[_key];\n\t            }\n\t\n\t            for (var i = 0; i < lists.length; i++) {\n\t                lists[i].apply(lists, argz);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'addListener',\n\t        value: function addListener() {\n\t            this.on.apply(this, arguments);\n\t        }\n\t    }, {\n\t        key: 'removeListener',\n\t        value: function removeListener() {\n\t            this.un.apply(this, arguments);\n\t        }\n\t    }, {\n\t        key: 'removeAllListeners',\n\t        value: function removeAllListeners() {\n\t            this._events = {};\n\t        }\n\t    }, {\n\t        key: 'once',\n\t        value: function once(evt, cb) {\n\t            var _this3 = this;\n\t\n\t            var _fn = void 0;\n\t            this.on(evt, _fn = function fn() {\n\t                _this3.un(evt, _fn);\n\t                cb.apply(undefined, arguments);\n\t            });\n\t        }\n\t    }]);\n\t\n\t    return Emitter;\n\t}();\n\t\n\texports.default = Emitter;\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t/*\n\t * Copyright (c) 2018.  Caipi Labs.  All rights reserved.\n\t *\n\t * This File is part of Caipi. You can redistribute it and/or modify\n\t * it under the terms of the GNU Affero General Public License as\n\t * published by the Free Software Foundation, either version 3 of the\n\t * License, or (at your option) any later version.\n\t * This program is distributed in the hope that it will be useful,\n\t * but WITHOUT ANY WARRANTY; without even the implied warranty of\n\t * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\t * GNU Affero General Public License for more details.\n\t * You should have received a copy of the GNU Affero General Public License\n\t * along with this program. If not, see <http://www.gnu.org/licenses/>.\n\t *  This project is dual licensed under AGPL and Commercial Licence.\n\t *\n\t * @author : Nathanael Braun\n\t * @contact : caipilabs@gmail.com\n\t */\n\t\n\tvar is = __webpack_require__(1),\n\t    EventEmitter = __webpack_require__(2),\n\t    shortid = __webpack_require__(4),\n\t    __proto__push = function __proto__push(target, id, parent) {\n\t    var fn = function fn() {};\n\t    fn.prototype = parent ? new parent[\"_\" + id]() : target[id] || {};\n\t    target[id] = new fn();\n\t    target['_' + id] = fn;\n\t},\n\t    openScopes = {};\n\t\n\tvar Scope = function (_EventEmitter) {\n\t    _inherits(Scope, _EventEmitter);\n\t\n\t    _createClass(Scope, null, [{\n\t        key: 'getScope',\n\t        // all active scopes\n\t\n\t        // if > 0, will wait 'persistenceTm' ms before destroy when dispose reach 0\n\t        value: function getScope(scopes) {\n\t            var skey = is.array(scopes) ? scopes.sort(function (a, b) {\n\t                if (a.firstname < b.firstname) return -1;\n\t                if (a.firstname > b.firstname) return 1;\n\t                return 0;\n\t            }).join('::') : scopes;\n\t            return openScopes[skey] = openScopes[skey] || new Scope({}, { id: skey });\n\t        }\n\t    }]);\n\t\n\t    /**\n\t     * Init a Rescope scope\n\t     *\n\t     * @param storesMap {Object} Object with the origin stores\n\t     * @param id {string} @optional id ( if this id exist storesMap will be merge on the 'id' scope)\n\t     * @param parent\n\t     * @param state\n\t     * @param data\n\t     * @param name\n\t     * @param defaultMaxListeners\n\t     * @param persistenceTm {number) if > 0, will wait 'persistenceTm' ms before destroy when dispose reach 0\n\t     * @param autoDestroy  {bool} will trigger retain & dispose after start\n\t     * @returns {Scope}\n\t     */\n\t    function Scope(storesMap) {\n\t        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n\t            id = _ref.id,\n\t            parent = _ref.parent,\n\t            state = _ref.state,\n\t            data = _ref.data,\n\t            name = _ref.name,\n\t            incrementId = _ref.incrementId,\n\t            defaultMaxListeners = _ref.defaultMaxListeners,\n\t            persistenceTm = _ref.persistenceTm,\n\t            autoDestroy = _ref.autoDestroy,\n\t            rootEmitter = _ref.rootEmitter;\n\t\n\t        _classCallCheck(this, Scope);\n\t\n\t        var _this = _possibleConstructorReturn(this, (Scope.__proto__ || Object.getPrototypeOf(Scope)).call(this));\n\t\n\t        _this._maxListeners = defaultMaxListeners || _this.constructor.defaultMaxListeners;\n\t        id = id || \"_____\" + shortid.generate();\n\t        if (openScopes[id] && !incrementId) {\n\t            var _ret;\n\t\n\t            _this._id = id;\n\t            openScopes[id].register(storesMap);\n\t            return _ret = openScopes[id], _possibleConstructorReturn(_this, _ret);\n\t        } else if (openScopes[id] && incrementId) {\n\t            var i = -1;\n\t            while (openScopes[id + '/' + ++i]) {}\n\t            id = id + '/' + i;\n\t        }\n\t\n\t        _this._id = id;\n\t        openScopes[id] = _this;\n\t        _this._isLocalId = true;\n\t        _this._persistenceTm = persistenceTm || _this.constructor.persistenceTm;\n\t\n\t        _this.stores = {};\n\t        _this.state = {};\n\t        _this.data = {};\n\t\n\t        if (parent && parent.dead) throw new Error(\"Can't use a dead scope as parent !\");\n\t\n\t        __proto__push(_this, 'stores', parent);\n\t        __proto__push(_this, 'state', parent);\n\t        __proto__push(_this, 'data', parent);\n\t        _this.parent = parent;\n\t\n\t        _this.sources = [];\n\t        _this._childScopes = [];\n\t        _this._childScopesList = [];\n\t        _this._unStableChilds = 0;\n\t\n\t        _this.__retains = { all: 0 };\n\t        _this.__locks = { all: 1 };\n\t        _this.__listening = {};\n\t        _this.__scope = {};\n\t        _this.__mixed = [];\n\t        _this.__mixedList = [];\n\t        _this._followers = [];\n\t        if (parent) {\n\t            parent.retain(\"isMyParent\");\n\t            if (!rootEmitter) {\n\t                !parent._stable && _this.wait(\"waitingParent\");\n\t                parent.on(_this.__parentList = {\n\t                    'stable': function stable(s) {\n\t                        return _this.release(\"waitingParent\");\n\t                    },\n\t                    'unstable': function unstable(s) {\n\t                        return _this.wait(\"waitingParent\");\n\t                    },\n\t                    'update': function update(s) {\n\t                        return _this._propag();\n\t                    }\n\t                });\n\t            } else {\n\t                parent.on(_this.__parentList = {\n\t                    'update': function update(s) {\n\t                        return _this._propag();\n\t                    }\n\t                });\n\t            }\n\t            // this.register(parent.__scope, state, data);\n\t        }\n\t\n\t        _this.register(storesMap, state, data);\n\t        _this.__locks.all--;\n\t        _this._stable = !_this.__locks.all;\n\t\n\t        if (parent) {\n\t            parent._addChild(_this);\n\t        }\n\t        if (autoDestroy) setTimeout(function (tm) {\n\t            _this.retain(\"autoDestroy\");\n\t            _this.dispose(\"autoDestroy\");\n\t        });\n\t        return _this;\n\t    }\n\t\n\t    /**\n\t     * @deprecated\n\t     * @returns {*}\n\t     */\n\t\n\t\n\t    _createClass(Scope, [{\n\t        key: 'mount',\n\t\n\t\n\t        /**\n\t         *\n\t         * Mount the stores in storesList, in this scope or in its parents or mixed scopes\n\t         *\n\t         * @param storesList {string|storeRef} Store name, Array of Store names, or Rescope store ref from Store::as or\n\t         *     Store:as\n\t         * @param state\n\t         * @param data\n\t         * @returns {Scope}\n\t         */\n\t        value: function mount(storesList, state, data) {\n\t            var _this2 = this;\n\t\n\t            if (is.array(storesList)) {\n\t                storesList.forEach(function (k) {\n\t                    return _this2._mount(k, state && state[k], data && data[k]);\n\t                });\n\t            } else {\n\t                this._mount.apply(this, arguments);\n\t            }\n\t            return this;\n\t        }\n\t    }, {\n\t        key: '_mount',\n\t        value: function _mount(id, state, data) {\n\t            if (typeof id !== 'string') {\n\t                this.register(_defineProperty({}, id.name, id.store));\n\t                id = id.name;\n\t            }\n\t\n\t            if (!this.__scope[id]) {\n\t                var _parent;\n\t\n\t                //ask mixed || parent\n\t                if (this.__mixed.reduce(function (mounted, ctx) {\n\t                    return mounted || ctx._mount(id, state, data);\n\t                }, false) || !this.parent) return;\n\t                return (_parent = this.parent)._mount.apply(_parent, arguments);\n\t            }\n\t            var store = this.__scope[id],\n\t                ctx = void 0;\n\t            if (is.fn(store)) {\n\t                this.__scope[id] = new store(this, { state: state, data: data });\n\t            } else {\n\t                if (state !== undefined && data === undefined) store.setState(state);else if (state !== undefined) store.state = state;\n\t\n\t                if (data !== undefined) store.push(data);\n\t            }\n\t\n\t            this._watchStore(id);\n\t\n\t            return this.__scope[id];\n\t        }\n\t    }, {\n\t        key: '_watchStore',\n\t        value: function _watchStore(id, state, data) {\n\t            var _this3 = this;\n\t\n\t            if (!this.__scope[id]) {\n\t                var _parent2;\n\t\n\t                //ask mixed || parent\n\t                if (this.__mixed.reduce(function (mounted, ctx) {\n\t                    return mounted || ctx._watchStore(id, state, data);\n\t                }, false) || !this.parent) return;\n\t                return (_parent2 = this.parent)._watchStore.apply(_parent2, arguments);\n\t            }\n\t            if (!this.__listening[id] && !is.fn(this.__scope[id])) {\n\t                !this.__scope[id].isStable() && this.wait(id);\n\t                this.__scope[id].on(this.__listening[id] = {\n\t                    'destroy': function destroy(s) {\n\t                        delete _this3.__listening[id];\n\t                        _this3.__scope[id] = _this3.__scope[id].constructor;\n\t                    },\n\t                    'update': function update(s) {\n\t                        return _this3.propag();\n\t                    },\n\t                    'stable': function stable(s) {\n\t                        return _this3.release(id);\n\t                    },\n\t                    'unstable': function unstable(s) {\n\t                        return _this3.wait(id);\n\t                    }\n\t                });\n\t            }\n\t            return true;\n\t        }\n\t\n\t        /**\n\t         * Mix targetCtx on this scope\n\t         * Mixed scope parents are NOT mapped\n\t         * @param targetCtx\n\t         */\n\t\n\t    }, {\n\t        key: 'mixin',\n\t        value: function mixin(targetCtx) {\n\t            var _this4 = this;\n\t\n\t            var parent = this.parent,\n\t                lists = void 0;\n\t            this.__mixed.push(targetCtx);\n\t            targetCtx.retain(\"mixedTo\");\n\t            if (!targetCtx._stable) this.wait(targetCtx._id);\n\t\n\t            this.__mixedList.push(lists = {\n\t                'stable': function stable(s) {\n\t                    return _this4.release(targetCtx._id);\n\t                },\n\t                'unstable': function unstable(s) {\n\t                    return _this4.wait(targetCtx._id);\n\t                },\n\t                'update': function update(s) {\n\t                    return _this4._propag();\n\t                }\n\t            });\n\t\n\t            this.stores = {};\n\t            this.state = {};\n\t            this.data = {};\n\t            targetCtx.on(lists);\n\t            __proto__push(this, 'stores', parent);\n\t            __proto__push(this, 'state', parent);\n\t            __proto__push(this, 'data', parent);\n\t\n\t            this.relink(this.__scope, this, false, true);\n\t            this.__mixed.forEach(function (ctx) {\n\t                __proto__push(_this4, 'stores');\n\t                __proto__push(_this4, 'state');\n\t                __proto__push(_this4, 'data');\n\t                ctx.relink(ctx.__scope, _this4, true, true);\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Register stores in storesMap & link them in the protos\n\t         * @param storesMap\n\t         * @param state\n\t         * @param data\n\t         */\n\t\n\t    }, {\n\t        key: 'register',\n\t        value: function register(storesMap) {\n\t            var _this5 = this;\n\t\n\t            var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t            var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\t\n\t            this.relink(storesMap, this, false, false);\n\t            Object.keys(storesMap).forEach(function (id) {\n\t                if (storesMap[id].singleton || is.fn(storesMap[id]) && (state[id] || data[id])) {\n\t                    _this5._mount(id, state[id], data[id]);\n\t                } else if (state[id] || data[id]) {\n\t                    if (data[id]) {\n\t                        if (state[id]) _this5.stores[id].state = state[id];\n\t                        _this5.stores[id].push(data[id]);\n\t                    } else if (state[id]) {\n\t                        _this5.stores[id].setState(state[id]);\n\t                    }\n\t                } else {\n\t                    _this5._watchStore(id);\n\t                }\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Map srcCtx store's on targetCtx headers proto's\n\t         * @param srcCtx\n\t         * @param targetCtx\n\t         * @param state\n\t         * @param data\n\t         */\n\t\n\t    }, {\n\t        key: 'relink',\n\t        value: function relink(srcCtx) {\n\t            var targetCtx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;\n\t\n\t            var _this6 = this;\n\t\n\t            var external = arguments[2];\n\t            var force = arguments[3];\n\t\n\t            var lctx = targetCtx._stores.prototype;\n\t            Object.keys(srcCtx).forEach(function (id) {\n\t                if (!force && targetCtx.__scope[id] === srcCtx[id] || targetCtx.__scope[id] && targetCtx.__scope[id].constructor === srcCtx[id]) return;\n\t\n\t                if (!force && targetCtx.__scope[id]) {\n\t                    if (!external && !is.fn(targetCtx.__scope[id])) {\n\t                        console.info(\"Rescope Store : \", id, \" already exist in this scope ! ( try __proto__ hot patch )\");\n\t                        targetCtx.__scope[id].__proto__ = srcCtx[id].prototype;\n\t                    }\n\t                    if (!external && is.fn(targetCtx.__scope[id])) targetCtx.__scope[id] = srcCtx[id];\n\t\n\t                    return;\n\t                } else if (!force && !external) _this6.__scope[id] = srcCtx[id];\n\t\n\t                Object.defineProperty(lctx, id, {\n\t                    get: function get() {\n\t                        return _this6.__scope[id];\n\t                    }\n\t                });\n\t                Object.defineProperty(targetCtx._state.prototype, id, {\n\t                    get: function get() {\n\t                        return _this6.__scope[id] && _this6.__scope[id].state;\n\t                    },\n\t                    set: function set(v) {\n\t                        return _this6._mount(id, v);\n\t                    }\n\t                });\n\t                Object.defineProperty(targetCtx._data.prototype, id, {\n\t                    get: function get() {\n\t                        return _this6.__scope[id] && _this6.__scope[id].data;\n\t                    },\n\t                    set: function set(v) {\n\t                        return _this6._mount(id, undefined, v);\n\t                    }\n\t                });\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Bind stores from this scope, his parents and mixed scope\n\t         *\n\t         * @param obj {React.Component|Store|function}\n\t         * @param key {string} stores keys to bind updates\n\t         * @param as\n\t         * @param setInitial {bool} false to not propag initial value (default : true)\n\t         */\n\t\n\t    }, {\n\t        key: 'bind',\n\t        value: function bind(obj, key, as) {\n\t            var setInitial = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\t\n\t            var lastRevs = void 0,\n\t                data = void 0,\n\t                reKey = void 0;\n\t            if (key && !is.array(key)) key = [key];\n\t\n\t            if (as === false || as === true) {\n\t                setInitial = as;\n\t                as = null;\n\t            }\n\t\n\t            reKey = key.map(function (id) {\n\t                return is.string(id) ? id : id.name;\n\t            });\n\t\n\t            this._followers.push([obj, key, as || undefined, lastRevs = reKey && reKey.reduce(function (revs, id) {\n\t                return revs[id] = 0, revs;\n\t            }, {})]);\n\t\n\t            this.mount(key);\n\t\n\t            if (setInitial && this._stable) {\n\t                data = this.getUpdates(lastRevs);\n\t                if (!data) return;\n\t                if (typeof obj != \"function\") {\n\t                    if (as) obj.setState(_defineProperty({}, as, data));else obj.setState(data);\n\t                } else {\n\t                    obj(data);\n\t                }\n\t            }\n\t            return this;\n\t        }\n\t\n\t        /**\n\t         * Un bind this scope off the given component-keys\n\t         * @param obj\n\t         * @param key\n\t         * @returns {Array.<*>}\n\t         */\n\t\n\t    }, {\n\t        key: 'unBind',\n\t        value: function unBind(obj, key, as) {\n\t            var followers = this._followers,\n\t                i = followers && followers.length;\n\t            while (followers && i--) {\n\t                if (followers[i][0] === obj && '' + followers[i][1] == '' + key && followers[i][2] == as) return followers.splice(i, 1);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Mount the stores in storesList from this scope, its parents and mixed scope\n\t         * Bind them to 'to'\n\t         * Hook 'to' so it will auto unbind on 'destroy' or 'componentWillUnmount'\n\t         * @param to\n\t         * @param storesList\n\t         * @param bind\n\t         * @returns {Object} Initial outputs of the stores in 'storesList'\n\t         */\n\t\n\t    }, {\n\t        key: 'map',\n\t        value: function map(to, storesList) {\n\t            var _this7 = this;\n\t\n\t            var bind = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\t\n\t            var Store = this.constructor.Store;\n\t            storesList = is.array(storesList) ? storesList : [storesList];\n\t            this.mount(storesList);\n\t            if (bind && to instanceof Store) {\n\t                Store.map(to, storesList, this, this, false);\n\t            } else if (bind) {\n\t                this.bind(to, storesList, undefined, false);\n\t\n\t                var mixedCWUnmount = void 0,\n\t                    unMountKey = to.isReactComponent ? \"componentWillUnmount\" : \"destroy\";\n\t\n\t                if (to.hasOwnProperty(unMountKey)) {\n\t                    mixedCWUnmount = to[unMountKey];\n\t                }\n\t\n\t                to[unMountKey] = function () {\n\t                    delete to[unMountKey];\n\t                    if (mixedCWUnmount) to[unMountKey] = mixedCWUnmount;\n\t\n\t                    _this7.unBind(to, storesList);\n\t                    return to[unMountKey] && to[unMountKey].apply(to, arguments);\n\t                };\n\t            }\n\t            return storesList.reduce(function (data, id) {\n\t                if (!is.string(id)) id = id.name;\n\t                id = id.split(':'); //@todo\n\t                id[0] = id[0].split('.');\n\t                data[id[1] || id[0][id[0].length - 1]] = _this7.stores[id[0][0]] && _this7.stores[id[0][0]].retrieve && _this7.stores[id[0][0]].retrieve(id[0].splice(1));\n\t                return data;\n\t            }, {});\n\t        }\n\t    }, {\n\t        key: 'retrieve',\n\t        value: function retrieve() {\n\t            var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n\t\n\t            path = is.string(path) ? path.split('.') : path;\n\t            return path && this.stores[path[0]] && this.stores[path[0]].retrieve(path.splice(1));\n\t        }\n\t\n\t        /**\n\t         * Get or update storesRevMap's revisions\n\t         * @param storesRevMap\n\t         * @param local\n\t         * @returns {{}}\n\t         */\n\t\n\t    }, {\n\t        key: 'getStoresRevs',\n\t        value: function getStoresRevs() {\n\t            var storesRevMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t            var local = arguments[1];\n\t\n\t            var ctx = this.__scope;\n\t            if (!storesRevMap) {\n\t                storesRevMap = {};\n\t            }\n\t            Object.keys(ctx).forEach(function (id) {\n\t                if (!is.fn(ctx[id])) {\n\t                    storesRevMap[id] = ctx[id]._rev;\n\t                } else if (!storesRevMap.hasOwnProperty(id)) storesRevMap[id] = false;\n\t            });\n\t            if (!local) {\n\t                this.__mixed.reduce(function (updated, ctx) {\n\t                    return ctx.getStoresRevs(storesRevMap), storesRevMap;\n\t                }, storesRevMap);\n\t                this.parent && this.parent.getStoresRevs(storesRevMap);\n\t            }\n\t            return storesRevMap;\n\t        }\n\t\n\t        /**\n\t         * Get or update output basing storesRevMap's revisions.\n\t         * If a store in 'storesRevMap' is updated; add it to 'output'\n\t         * @param storesRevMap\n\t         * @param output\n\t         * @param updated\n\t         * @returns {*|{}}\n\t         */\n\t\n\t    }, {\n\t        key: 'getUpdates',\n\t        value: function getUpdates(storesRevMap, output, updated) {\n\t            var _this8 = this;\n\t\n\t            var ctx = this.__scope;\n\t\n\t            output = output || {};\n\t            Object.keys(ctx).forEach(function (id) {\n\t                if (!output[id] && (!storesRevMap || storesRevMap.hasOwnProperty(id) && storesRevMap[id] === undefined || !(!storesRevMap.hasOwnProperty(id) || ctx[id]._rev <= storesRevMap[id]))) {\n\t\n\t                    updated = true;\n\t                    output[id] = _this8.data[id];\n\t                    if (storesRevMap && storesRevMap[id] !== undefined) storesRevMap[id] = ctx[id]._rev;\n\t                }\n\t            });\n\t            updated = this.__mixed.reduce(function (updated, ctx) {\n\t                return ctx.getUpdates(storesRevMap, output, updated) || updated;\n\t            }, updated);\n\t            updated = this.parent && this.parent.getUpdates(storesRevMap, output, updated) || updated;\n\t            return updated && output;\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param flags_states\n\t         * @param flags_data\n\t         * @returns {{state: {}, data: {}}}\n\t         */\n\t\n\t    }, {\n\t        key: 'serialize',\n\t        value: function serialize() {\n\t            var _this9 = this;\n\t\n\t            var flags_states = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : /.*/;\n\t            var flags_data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /.*/;\n\t\n\t            var ctx = this.__scope,\n\t                output = { state: {}, data: {} },\n\t                _flags_states = void 0,\n\t                _flags_data = void 0;\n\t            if (is.array(flags_states)) flags_states.forEach(function (id) {\n\t                return output.state[id] = _this9.state[id];\n\t            });\n\t\n\t            if (is.array(flags_data)) flags_data.forEach(function (id) {\n\t                return output.data[id] = _this9.data[id];\n\t            });\n\t\n\t            if (!is.array(flags_data) && !is.array(flags_states)) Object.keys(ctx).forEach(function (id) {\n\t                if (is.fn(ctx[id])) return;\n\t\n\t                var flags = ctx[id].constructor.flags;\n\t\n\t                flags = is.array(flags) ? flags : [flags || \"\"];\n\t\n\t                if (flags.reduce(function (r, flag) {\n\t                    return r || flags_states.test(flag);\n\t                }, false)) output.state[id] = _this9.state[id];\n\t\n\t                if (flags.reduce(function (r, flag) {\n\t                    return r || flags_data.test(flag);\n\t                }, false)) output.data[id] = _this9.data[id];\n\t            });\n\t            return output;\n\t        }\n\t    }, {\n\t        key: 'dispatch',\n\t        value: function dispatch(action, data) {\n\t            var _this10 = this;\n\t\n\t            Object.keys(this.__scope).forEach(function (id) {\n\t                if (!is.fn(_this10.__scope[id])) _this10.__scope[id].trigger(action, data);\n\t            });\n\t\n\t            this.__mixed.forEach(function (ctx) {\n\t                return ctx.dispatch(action, data);\n\t            });\n\t            this.parent && this.parent.dispatch(action, data);\n\t            return this;\n\t        }\n\t\n\t        /**\n\t         * once('stable', cb)\n\t         * @param obj {React.Component|Store|function)\n\t         * @param key {string} optional key where to map the public state\n\t         */\n\t\n\t    }, {\n\t        key: 'then',\n\t        value: function then(cb) {\n\t            var _this11 = this;\n\t\n\t            if (this._stable) return cb(null, this.data);\n\t            this.once('stable', function (e) {\n\t                return cb(null, _this11.data);\n\t            });\n\t        }\n\t    }, {\n\t        key: 'restore',\n\t        value: function restore(_ref2, quiet) {\n\t            var state = _ref2.state,\n\t                data = _ref2.data;\n\t\n\t            var ctx = this.__scope;\n\t            Object.keys(data).forEach(function (id) {\n\t                quiet ? ctx.data = data[id] : ctx.push(data[id]);\n\t            });\n\t            Object.keys(state).forEach(function (id) {\n\t                quiet ? ctx.state = state[id] : ctx.setState(state[id]);\n\t            });\n\t        }\n\t    }, {\n\t        key: 'retainStores',\n\t        value: function retainStores() {\n\t            var _this12 = this;\n\t\n\t            var stores = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\t            var reason = arguments[1];\n\t\n\t            stores.forEach(function (id) {\n\t                return _this12.stores[id] && _this12.stores[id].retain && _this12.stores[id].retain(reason);\n\t            });\n\t        }\n\t    }, {\n\t        key: 'disposeStores',\n\t        value: function disposeStores() {\n\t            var _this13 = this;\n\t\n\t            var stores = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\t            var reason = arguments[1];\n\t\n\t            stores.forEach(function (id) {\n\t                return _this13.stores[id] && _this13.stores[id].dispose && _this13.stores[id].dispose(reason);\n\t            });\n\t        }\n\t    }, {\n\t        key: 'wait',\n\t        value: function wait(reason) {\n\t            //console.log(\"wait\", reason);\n\t            this._stable && !this.__locks.all && this.emit(\"unstable\", this);\n\t            this._stable = false;\n\t            this.__locks.all++;\n\t            if (reason) {\n\t                this.__locks[reason] = this.__locks[reason] || 0;\n\t                this.__locks[reason]++;\n\t            }\n\t        }\n\t    }, {\n\t        key: 'release',\n\t        value: function release(reason) {\n\t            var _this14 = this;\n\t\n\t            if (reason) {\n\t                if (this.__locks[reason] == 0) console.error(\"Release more than locking !\", reason);\n\t                this.__locks[reason] = this.__locks[reason] || 0;\n\t                this.__locks[reason]--;\n\t            }\n\t            if (!reason && this.__locks.all == 0) console.error(\"Release more than locking !\");\n\t\n\t            this.__locks.all--;\n\t            if (!this.__locks.all) {\n\t                this._stabilizerTM && clearTimeout(this._stabilizerTM);\n\t\n\t                this._stabilizerTM = setTimeout(function (e) {\n\t                    _this14._stabilizerTM = null;\n\t                    if (_this14.__locks.all) return;\n\t\n\t                    _this14._propagTM && clearTimeout(_this14._propagTM);\n\t\n\t                    _this14._stable = true;\n\t                    _this14.emit(\"stable\", _this14);\n\t\n\t                    !_this14.dead && _this14._propag(); // stability can induce destroy\n\t                });\n\t            }\n\t        }\n\t    }, {\n\t        key: 'propag',\n\t        value: function propag() {\n\t            var _this15 = this;\n\t\n\t            this._propagTM && clearTimeout(this._propagTM);\n\t            this._propagTM = setTimeout(function (e) {\n\t                _this15._propagTM = null;\n\t                _this15._propag();\n\t            }, 2);\n\t        }\n\t    }, {\n\t        key: '_propag',\n\t        value: function _propag() {\n\t            var _this16 = this;\n\t\n\t            if (this._followers.length) this._followers.forEach(function (_ref3) {\n\t                var obj = _ref3[0],\n\t                    key = _ref3[1],\n\t                    as = _ref3[2],\n\t                    lastRevs = _ref3[3];\n\t\n\t                var data = _this16.getUpdates(lastRevs);\n\t                if (!data) return;\n\t                if (typeof obj != \"function\") {\n\t                    if (as) obj.setState(_defineProperty({}, as, data));else obj.setState(data);\n\t                } else {\n\t                    obj(data, lastRevs && [].concat(_toConsumableArray(lastRevs)) || \"no revs\");\n\t                }\n\t                // lastRevs &&\n\t                // key.forEach(id => (lastRevs[id] = this.stores[id] && this.stores[id]._rev || 0));\n\t            });\n\t            this.emit(\"update\", this.getUpdates());\n\t        }\n\t\n\t        /**\n\t         * is stable\n\t         * @returns bool\n\t         */\n\t\n\t    }, {\n\t        key: 'isStable',\n\t        value: function isStable() {\n\t            return this._stable;\n\t        }\n\t\n\t        //serializeChilds( childs = [] ) {\n\t        //\n\t        //}\n\t\n\t    }, {\n\t        key: '_addChild',\n\t        value: function _addChild(ctx) {\n\t            var _this17 = this;\n\t\n\t            this._childScopes.push(ctx);\n\t            var lists = {\n\t                'stable': function stable(s) {\n\t                    _this17._unStableChilds--;\n\t                    if (!_this17._unStableChilds) _this17.emit(\"stableTree\", _this17);\n\t                },\n\t                'unstable': function unstable(s) {\n\t                    _this17._unStableChilds++;\n\t                    if (1 == _this17._unStableChilds) _this17.emit(\"unstableTree\", _this17);\n\t                },\n\t                'stableTree': function stableTree(s) {\n\t                    _this17._unStableChilds--;\n\t                    if (!_this17._unStableChilds) _this17.emit(\"stableTree\", _this17);\n\t                },\n\t                'unstableTree': function unstableTree(s) {\n\t                    _this17._unStableChilds++;\n\t                    if (1 == _this17._unStableChilds) _this17.emit(\"unstableTree\", _this17);\n\t                },\n\t                'destroy': function destroy(ctx) {\n\t                    if (ctx._unStableChilds) _this17._unStableChilds--;\n\t                    if (!ctx.isStable()) _this17._unStableChilds--;\n\t\n\t                    if (!_this17._unStableChilds) _this17.emit(\"stableTree\", _this17);\n\t                }\n\t            },\n\t                wasStable = this._unStableChilds;\n\t            //!ctx.isStable() && console.warn('add unstable child');\n\t            !ctx.isStable() && this._unStableChilds++;\n\t            ctx._unStableChilds && this._unStableChilds++;\n\t            this._childScopesList.push(lists);\n\t            if (!wasStable && this._unStableChilds) this.emit(\"unstableTree\", this);\n\t            ctx.on(lists);\n\t        }\n\t    }, {\n\t        key: '_rmChild',\n\t        value: function _rmChild(ctx) {\n\t            var i = this._childScopes.indexOf(ctx),\n\t                wasStable = this._unStableChilds;\n\t            if (i != -1) {\n\t                this._childScopes.splice(i, 1);\n\t                !ctx.isStable() && this._unStableChilds--;\n\t                ctx._unStableChilds && this._unStableChilds--;\n\t                ctx.un(this._childScopesList.splice(i, 1)[0]);\n\t                if (wasStable && !this._unStableChilds) this.emit(\"stableTree\");\n\t            }\n\t        }\n\t    }, {\n\t        key: 'retain',\n\t        value: function retain(reason) {\n\t            this.__retains.all++;\n\t            //console.log(\"retain\", this._id, reason);\n\t            if (reason) {\n\t                this.__retains[reason] = this.__retains[reason] || 0;\n\t                this.__retains[reason]++;\n\t            }\n\t        }\n\t    }, {\n\t        key: 'dispose',\n\t        value: function dispose(reason) {\n\t            var _this18 = this;\n\t\n\t            //console.log(\"dispose\", this._id, reason);\n\t            if (reason) {\n\t                if (!this.__retains[reason]) throw new Error(\"Dispose more than retaining : \" + reason);\n\t                this.__retains[reason]--;\n\t            }\n\t\n\t            if (!this.__retains.all) throw new Error(\"Dispose more than retaining !\");\n\t\n\t            this.__retains.all--;\n\t\n\t            if (!this.__retains.all) {\n\t                //console.log(\"dispose do destroy \", this._id, this._persistenceTm);\n\t                if (this._persistenceTm) {\n\t                    this._destroyTM && clearTimeout(this._destroyTM);\n\t                    this._destroyTM = setTimeout(function (e) {\n\t                        _this18.then(function (s) {\n\t                            !_this18.__retains.all && _this18.destroy();\n\t                        });\n\t                    }, this._persistenceTm);\n\t                } else {\n\t                    this.then(function (s) {\n\t                        return !_this18.__retains.all && _this18.destroy();\n\t                    });\n\t                }\n\t            }\n\t        }\n\t\n\t        /**\n\t         * order destroy of local stores\n\t         */\n\t\n\t    }, {\n\t        key: 'destroy',\n\t        value: function destroy() {\n\t            var _this19 = this;\n\t\n\t            var ctx = this.__scope;\n\t            //console.warn(\"destroy\", this._id);\n\t            this.dead = true;\n\t            this.emit(\"destroy\", this);\n\t            Object.keys(this.__listening).forEach(function (id) {\n\t                return _this19.__scope[id].removeListener(_this19.__listening[id]);\n\t            });\n\t\n\t            this._stabilizerTM && clearTimeout(this._stabilizerTM);\n\t            this._propagTM && clearTimeout(this._propagTM);\n\t            this.__listening = {};\n\t\n\t            if (this._isLocalId) delete openScopes[this._id];\n\t            this._followers.length = 0;\n\t\n\t            while (this.__mixedList.length) {\n\t                this.__mixed[0].removeListener(this.__mixedList.shift());\n\t                this.__mixed.shift().dispose(\"mixedTo\");\n\t            }\n\t            if (this.__parentList) {\n\t                this.parent._rmChild(this);\n\t                this.parent.removeListener(this.__parentList);\n\t                this.parent.dispose(\"isMyParent\");\n\t                this.__parentList = null;\n\t            }\n\t            //for ( let key in ctx )\n\t            //    if ( !is.fn(ctx[key]) ) {\n\t            //        if ( ctx[key].scopeObj === this )\n\t            //            ctx[key].dispose();\n\t            //\n\t            //        ctx[key] = ctx[key].constructor;\n\t            //    }\n\t            this.__mixed = this.data = this.state = this.scope = this.stores = null;\n\t            this._data = this._state = this._stores = null;\n\t        }\n\t    }, {\n\t        key: 'datas',\n\t        get: function get() {\n\t            return this.data;\n\t        }\n\t    }]);\n\t\n\t    return Scope;\n\t}(EventEmitter);\n\t\n\tScope.persistenceTm = 1;\n\tScope.Store = null;\n\tScope.scopes = openScopes;\n\texports.default = Scope;\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"shortid\");\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t/*\n\t * Copyright (c)  2017 Caipi Labs .\n\t *\n\t * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\t *\n\t * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\t *\n\t * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t *\n\t * @author : Nathanael Braun\n\t * @contact : caipilabs@gmail.com\n\t */\n\t\n\t/**\n\t * Ultra scalable state-aware store\n\t *\n\t * @todo : lot of optims...\n\t */\n\t\n\tvar is = __webpack_require__(1),\n\t    Scope = __webpack_require__(3),\n\t    EventEmitter = __webpack_require__(2),\n\t    shortid = __webpack_require__(4),\n\t    objProto = Object.getPrototypeOf({});\n\t/**\n\t * @class Store\n\t */\n\t\n\tvar Store = function (_EventEmitter) {\n\t    _inherits(Store, _EventEmitter);\n\t\n\t    /**\n\t     * Constructor, will build a rescope store\n\t     *\n\t     * (scope, {require,use,apply,state, data})\n\t     * (scope)\n\t     *\n\t     * @param scope {object} scope where to find the other stores (default : static staticScope )\n\t     * @param keys {Array} (passed to Store::map) Ex : [\"session\", \"otherNamedStore:key\", otherStore.as(\"otherKey\")]\n\t     */\n\t    // overridable list of store that will allow push if updated\n\t    function Store() {\n\t        var _this$_require, _this$_require2;\n\t\n\t        _classCallCheck(this, Store);\n\t\n\t        var _this = _possibleConstructorReturn(this, (Store.__proto__ || Object.getPrototypeOf(Store)).call(this));\n\t\n\t        var argz = [].concat(Array.prototype.slice.call(arguments)),\n\t            _static = _this.constructor,\n\t            scope = argz[0] instanceof Scope ? argz.shift() : _static.scope ? Scope.getScope(_static.scope) : is.string(argz[0]) ? Scope.getScope(argz.shift()) : _static.staticScope,\n\t            cfg = argz[0] && !is.array(argz[0]) && !is.string(argz[0]) ? argz.shift() : {},\n\t            name = is.string(argz[0]) ? argz[0] : cfg.name || _static.name,\n\t            watchs = is.array(argz[0]) ? argz.shift() : cfg.use || [],\n\t            // watchs need to be defined after all the\n\t        // store are registered : so we can't deal\n\t        // with any \"static use\" automaticly\n\t        apply = is.fn(argz[0]) ? argz.shift() : cfg.apply || null,\n\t            initialState = _static.state || _static.initialState,\n\t            applied;\n\t\n\t        _this._uid = cfg._uid || shortid.generate();\n\t\n\t        _this.__retains = { all: 0 };\n\t        _this.__locks = { all: 0 };\n\t        _this._onStabilize = [];\n\t\n\t        _this._persistenceTm = cfg.persistenceTm || _this.constructor.persistenceTm;\n\t        if (is.string(argz[0])) {\n\t            if (scope.__scope[name]) console.warn(\"ReScope: Overwriting an existing static named store ( %s ) !!\", name);\n\t            scope.__scope[name] = _this;\n\t        }\n\t\n\t        if (cfg && cfg.on) {\n\t            _this.on(cfg.on);\n\t        }\n\t        // this.state      = this.state || {};\n\t\n\t\n\t        _this.name = name;\n\t\n\t        if (scope.stores) {\n\t            _this.scopeObj = scope;\n\t            _this.scope = scope.stores;\n\t        } else {\n\t            _this.scopeObj = new Scope(scope);\n\t            _this.scope = scope.stores;\n\t        }\n\t\n\t        _this._rev = _this.constructor._rev || 0;\n\t        _this._revs = {};\n\t        _this.stores = {};\n\t        _this._require = [];\n\t\n\t        if (is.array(_static.use)) {\n\t            _this._use = [].concat(_toConsumableArray(watchs), _toConsumableArray((_static.use || []).map(function (key) {\n\t                var ref = key.match(/^(\\!?)([^\\:]*)(?:\\:(.*))?$/);\n\t                if (ref[1]) {\n\t                    var ref2 = ref[2].split('.');\n\t                    _this._require.push(ref[3] || ref2[ref2.length - 1]);\n\t                }\n\t                return ref[2];\n\t            })));\n\t        } else {\n\t            _this._use = [].concat(_toConsumableArray(watchs), _toConsumableArray(_static.use ? Object.keys(_static.use).map(function (key) {\n\t                var ref = key.match(/^(\\!?)(.*)$/);\n\t                ref[1] && _this._require.push(_static.use[key]);\n\t                return ref[2] + (_static.use[key] === true ? '' : ':' + _static.use[key]);\n\t            }) : []));\n\t        }\n\t\n\t        if (_static.require) (_this$_require = _this._require).push.apply(_this$_require, _toConsumableArray(_static.require));\n\t        if (cfg.require) (_this$_require2 = _this._require).push.apply(_this$_require2, _toConsumableArray(cfg.require));\n\t\n\t        _this._followers = [];\n\t\n\t        if (_static.data !== undefined) _this.data = _extends({}, _static.data);\n\t        if (cfg.hasOwnProperty(\"data\") && cfg.data !== undefined) _this.data = cfg.data;\n\t        if (cfg.hasOwnProperty(\"state\") && cfg.state !== undefined) initialState = _extends({}, initialState, cfg.state);\n\t\n\t        if (apply) _this.apply = apply;\n\t\n\t        if (initialState || _this._use.length) {\n\t            // sync apply\n\t            _this.state = _extends({}, initialState || {}, scope.map(_this, _this._use));\n\t            if (_this.shouldApply(_this.state) && _this.data === undefined) {\n\t                _this.data = _this.apply(_this.data, _this.state, _this.state);\n\t                applied = true;\n\t            }\n\t        }\n\t\n\t        if ((_this.data !== undefined || applied) && !_this.__locks.all) {\n\t            _this._stable = true;\n\t            _this._rev++;\n\t        } else {\n\t            _this._stable = false;\n\t            if (!_static.managed && !_this.state && (!_this._use || !_this._use.length)) {\n\t                console.warn(\"Rescope store '\", _this.name, \"' have no initial data, state or use. It can't stabilize...\");\n\t            }\n\t        }\n\t        !_this._stable && _this.emit('unstable', _this.state);\n\t        return _this;\n\t    }\n\t\n\t    /**\n\t     * get a Builder-key pair for Store::map\n\t     * @param {string} name\n\t     * @returns {{store: Store, name: *}}\n\t     */\n\t    // default state\n\t    /**\n\t     * if retain goes to 0 :\n\t     * false to not destroy,\n\t     * 0 to sync auto destroy\n\t     * Ms to autodestroy after tm ms if no retain has been called\n\t     * @type {boolean|Int}\n\t     */\n\t    // overridable list of source stores\n\t\n\t\n\t    _createClass(Store, [{\n\t        key: 'shouldPropag',\n\t\n\t\n\t        /**\n\t         * Overridable method to know if a data change should be propag to the listening stores & components\n\t         */\n\t        value: function shouldPropag(nDatas) {\n\t            var _static = this.constructor,\n\t                r,\n\t                cDatas = this.data;\n\t            r = !cDatas && nDatas;\n\t            cDatas && Object.keys(cDatas).forEach(function (key) {\n\t                r = r || (nDatas ? cDatas[key] !== nDatas[key] : cDatas && cDatas[key]);\n\t            });\n\t            nDatas && Object.keys(nDatas).forEach(function (key) {\n\t                r = r || (nDatas ? cDatas[key] !== nDatas[key] : cDatas && cDatas[key]);\n\t            });\n\t            return !!r;\n\t        }\n\t\n\t        /**\n\t         * Overridable method to know if a state change should be applied\n\t         */\n\t\n\t    }, {\n\t        key: 'shouldApply',\n\t        value: function shouldApply() {\n\t            var _this2 = this;\n\t\n\t            var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state;\n\t\n\t            var _static = this.constructor;\n\t\n\t            return !!this.isComplete(state) && (is.array(_static.follow) ? _static.follow.reduce(function (r, i) {\n\t                return r || state && state[i];\n\t            }, false) : _static.follow ? Object.keys(_static.follow).reduce(function (r, i) {\n\t                return r || state && is.fn(_static.follow[i]) && _static.follow[i].call(_this2, state[i]) || _static.follow[i] && state[i] !== _this2.state[i];\n\t            }, false) : true);\n\t        }\n\t\n\t        /**\n\t         * Overridable applier / remapper\n\t         * If state or lastPublicState are simple hash maps apply will return {...data, ...state}\n\t         * if not it will return the last private state\n\t         * @param data\n\t         * @param state\n\t         * @returns {*}\n\t         */\n\t\n\t    }, {\n\t        key: 'apply',\n\t        value: function apply(data, state, changes) {\n\t            state = state || this.state;\n\t\n\t            if (this.refine) return this.refine.apply(this, arguments);\n\t\n\t            if (!data || data.__proto__ !== objProto || state.__proto__ !== objProto) return state;else return _extends({}, data, state);\n\t        }\n\t\n\t        /**\n\t         * @depreciated\n\t         * @param data\n\t         * @param state\n\t         * @param changes\n\t         * @returns {*}\n\t         */\n\t\n\t    }, {\n\t        key: 'refine',\n\t        value: function refine(data, state, changes) {\n\t            state = state || this.state;\n\t\n\t            if (!data || data.__proto__ !== objProto || state.__proto__ !== objProto) return state;else return _extends({}, data, state);\n\t        }\n\t\n\t        /**\n\t         * Debounce this store propagation ( & reducing )\n\t         * @param cb\n\t         */\n\t\n\t    }, {\n\t        key: 'stabilize',\n\t        value: function stabilize(cb) {\n\t            var _this3 = this;\n\t\n\t            cb && this.once('stable', cb);\n\t            this._stable && this.emit('unstable', this.state, this.data);\n\t\n\t            this._stable = false;\n\t\n\t            if (this._stabilizer) clearTimeout(this._stabilizer);\n\t\n\t            this._stabilizer = setTimeout(this.push.bind(this, null, function () {\n\t                //@todo\n\t\n\t                var stable = _this3._stable;\n\t                _this3._stable = true;\n\t                !stable && _this3.emit('stable', _this3.state, _this3.data);\n\t                _this3._stabilizer = null;\n\t                // this.release();\n\t            }));\n\t        }\n\t    }, {\n\t        key: 'retrieve',\n\t        value: function retrieve(path) {\n\t            var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t            var obj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.data;\n\t\n\t            path = is.string(path) ? path.split('.') : path;\n\t            return !obj || !path || !path.length ? obj : path.length == i + 1 ? obj[path[i]] : this.retrieve(path, i + 1, obj[path[i]]);\n\t        }\n\t    }, {\n\t        key: 'dispatch',\n\t        value: function dispatch(action) {\n\t            var _scopeObj;\n\t\n\t            for (var _len = arguments.length, argz = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t                argz[_key - 1] = arguments[_key];\n\t            }\n\t\n\t            (_scopeObj = this.scopeObj).dispatch.apply(_scopeObj, [action].concat(argz));\n\t        }\n\t    }, {\n\t        key: 'trigger',\n\t        value: function trigger(action) {\n\t            var actions = this.constructor.actions,\n\t                ns = void 0;\n\t\n\t            if (actions && actions[action]) {\n\t                var _actions$action;\n\t\n\t                for (var _len2 = arguments.length, argz = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n\t                    argz[_key2 - 1] = arguments[_key2];\n\t                }\n\t\n\t                ns = (_actions$action = actions[action]).call.apply(_actions$action, [this].concat(argz));\n\t                ns && this.setState(ns);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Pull stores in the private state\n\t         * @param stores  {Array} (passed to Store::map) Ex : [\"session\", \"otherNamedStore:key\", otherStore.as(\"otherKey\")]\n\t         */\n\t\n\t    }, {\n\t        key: 'pull',\n\t        value: function pull(stores, doWait, origin) {\n\t            var _this4 = this;\n\t\n\t            var initialOutputs = this.scopeObj.map(this, stores);\n\t            if (doWait) {\n\t                this.wait();\n\t                stores.forEach(function (s) {\n\t                    return _this4.scope[s] && _this4.wait(_this4.scope[s]);\n\t                });\n\t                this.release();\n\t            }\n\t            return initialOutputs;\n\t        }\n\t\n\t        /**\n\t         * Apply apply/remap on the private state & push the resulting \"public\" state to followers\n\t         * @param cb\n\t         */\n\t\n\t    }, {\n\t        key: 'push',\n\t        value: function push(data, force, cb) {\n\t            cb = force === true ? cb : force;\n\t            force = force === true;\n\t            var i = 0,\n\t                nextState = !data && _extends({}, this.state, this._changesSW) || this.state,\n\t                nextDatas = data || this.apply(this.data, nextState, this._changesSW);\n\t\n\t            this.state = nextState;\n\t            if (!force && (!this.data && this.data === nextDatas || !this.shouldPropag(nextDatas))) {\n\t                cb && cb();\n\t                return false;\n\t            }\n\t\n\t            this.data = nextDatas;\n\t            this._changesSW = {};\n\t            //this.__locks.all++;\n\t            this.wait();\n\t            this.release(cb);\n\t        }\n\t\n\t        /**\n\t         * Update the current private state & push it once the store is stable\n\t         * @param pState\n\t         * @param cb\n\t         */\n\t\n\t    }, {\n\t        key: 'setState',\n\t        value: function setState(pState, cb, sync) {\n\t            var i = 0,\n\t                change,\n\t                changes = this._changesSW = this._changesSW || {};\n\t            for (var k in pState) {\n\t                if (!this.state || pState.hasOwnProperty(k) && (pState[k] != this.state[k] || this.state[k] && pState[k] && pState[k]._rev != this._revs[k] // rev/hash update\n\t                )) {\n\t                    change = true;\n\t                    this._revs[k] = pState[k] && pState[k]._rev || true;\n\t                    changes[k] = pState[k];\n\t                }\n\t            }if (!this.shouldApply(_extends({}, this.state, changes))) {\n\t                return;\n\t            }\n\t\n\t            if (sync) {\n\t                this.push();\n\t                cb && cb();\n\t            } else {\n\t                if (change) {\n\t                    this.stabilize(cb);\n\t                } else cb && cb();\n\t            }\n\t            return this;\n\t        }\n\t\n\t        /**\n\t         * Update the current private state & push it once the store is stable\n\t         * @param pState\n\t         * @param cb\n\t         */\n\t\n\t    }, {\n\t        key: 'setStateSync',\n\t        value: function setStateSync(pState) {\n\t            var i = 0,\n\t                change,\n\t                changes = this._changesSW = this._changesSW || {};\n\t            for (var k in pState) {\n\t                if (!this.state || pState.hasOwnProperty(k) && (pState[k] != this.state[k] || this.state[k] && pState[k] && pState[k]._rev != this._revs[k] // rev/hash update\n\t                )) {\n\t                    change = true;\n\t                    this._revs[k] = pState[k] && pState[k]._rev || true;\n\t                    changes[k] = pState[k];\n\t                }\n\t            }this.shouldApply(_extends({}, this.state || {}, changes)) && this.push();\n\t            return this.data;\n\t        }\n\t\n\t        /**\n\t         * Replace the current private state & push it once the store is stable\n\t         * @param pState\n\t         * @param cb\n\t         */\n\t\n\t    }, {\n\t        key: 'replaceState',\n\t        value: function replaceState(pState, cb) {\n\t            var i = 0,\n\t                me = this;\n\t            this.state = pState;\n\t\n\t            this.stabilize(cb);\n\t        }\n\t\n\t        /**\n\t         * get a store-key pair for Store::map\n\t         * @param {string} name\n\t         * @returns {{store: Store, name: *}}\n\t         */\n\t\n\t    }, {\n\t        key: 'as',\n\t        value: function as(name) {\n\t            return { store: this, name: name };\n\t        }\n\t    }, {\n\t        key: 'on',\n\t        value: function on(lists) {\n\t            var _this5 = this;\n\t\n\t            if (!is.string(lists) && lists) Object.keys(lists).forEach(function (k) {\n\t                return _get(Store.prototype.__proto__ || Object.getPrototypeOf(Store.prototype), 'on', _this5).call(_this5, k, lists[k]);\n\t            });else _get(Store.prototype.__proto__ || Object.getPrototypeOf(Store.prototype), 'on', this).apply(this, arguments);\n\t        }\n\t    }, {\n\t        key: 'removeListener',\n\t        value: function removeListener(lists) {\n\t            var _this6 = this;\n\t\n\t            if (!is.string(lists) && lists) Object.keys(lists).forEach(function (k) {\n\t                return _get(Store.prototype.__proto__ || Object.getPrototypeOf(Store.prototype), 'removeListener', _this6).call(_this6, k, lists[k]);\n\t            });else _get(Store.prototype.__proto__ || Object.getPrototypeOf(Store.prototype), 'removeListener', this).apply(this, arguments);\n\t        }\n\t\n\t        /**\n\t         * relink bindings & requires\n\t         * @param {string} name\n\t         * @returns {{store: Store, name: *}}\n\t         */\n\t\n\t    }, {\n\t        key: 'relink',\n\t        value: function relink(from) {\n\t            var _this7 = this;\n\t\n\t            var scope = this.scopeObj,\n\t                _static = this.constructor;\n\t            if (_static.use) {\n\t                //todo unlink\n\t                this.pull(_static.use, false, from);\n\t            }\n\t\n\t            if (this._require) {\n\t                this._require.forEach(function (store) {\n\t                    return _this7.wait(scope.__scope[store]);\n\t                });\n\t            }\n\t        }\n\t\n\t        /**\n\t         * is complete (all requiered keys are here)\n\t         * @returns bool\n\t         */\n\t\n\t    }, {\n\t        key: 'isComplete',\n\t        value: function isComplete() {\n\t            var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state;\n\t\n\t            var _static = this.constructor;\n\t            return !this._require || !this._require.length || state && this._require.reduce(function (r, key) {\n\t                return r && state[key];\n\t            }, true);\n\t        }\n\t\n\t        /**\n\t         * is stable\n\t         * @returns bool\n\t         */\n\t\n\t    }, {\n\t        key: 'isStable',\n\t        value: function isStable() {\n\t            return this._stable;\n\t        }\n\t\n\t        /**\n\t         * Un bind this store off the given component-key\n\t         * @param obj\n\t         * @param key\n\t         * @returns {Array.<*>}\n\t         */\n\t\n\t    }, {\n\t        key: 'unBind',\n\t        value: function unBind(obj, key, path) {\n\t            var followers = this._followers,\n\t                i = followers && followers.length;\n\t            while (followers && i--) {\n\t                if (followers[i][0] === obj && followers[i][1] === key && followers[i][2] === path) return followers.splice(i, 1);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Bind this store changes to the given component-key\n\t         * @param obj {React.Component|Store|function)\n\t         * @param key {string} optional key where to map the public state\n\t         */\n\t\n\t    }, {\n\t        key: 'bind',\n\t        value: function bind(obj, key) {\n\t            var setInitial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\t            var path = arguments[3];\n\t\n\t            this._followers.push([obj, key, path]);\n\t            if (setInitial && this.data && this._stable) {\n\t                var data = path ? this.retrieve(path) : this.data;\n\t                if (typeof obj != \"function\") {\n\t                    if (key) obj.setState(_defineProperty({}, key, data));else obj.setState(data);\n\t                } else {\n\t                    obj(data);\n\t                }\n\t            }\n\t        }\n\t\n\t        /**\n\t         * once('stable', cb)\n\t         * @param obj {React.Component|Store|function)\n\t         * @param key {string} optional key where to map the public state\n\t         */\n\t\n\t    }, {\n\t        key: 'then',\n\t        value: function then(cb) {\n\t            var _this8 = this;\n\t\n\t            if (this._stable) return cb(null, this.data);\n\t            this.once('stable', function (e) {\n\t                return cb(null, _this8.data);\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Add a lock so the store will not propag it state untill release() is call\n\t         * @param previous {Store|number|Array} @optional wf to wait, releases to wait or array of stuff to wait\n\t         * @returns {TaskFlow}\n\t         */\n\t\n\t    }, {\n\t        key: 'wait',\n\t        value: function wait(previous) {\n\t            if (typeof previous == \"number\") return this.__locks.all += previous;\n\t            if (is.array(previous)) return previous.map(this.wait.bind(this));\n\t\n\t            this._stable && this.emit('unstable', this.state, this.data);\n\t            this._stable = false;\n\t            this.__locks.all++;\n\t\n\t            var reason = is.string(previous) ? previous : null;\n\t            if (reason) {\n\t                this.__locks[reason] = this.__locks[reason] || 0;\n\t                this.__locks[reason]++;\n\t            }\n\t            if (previous && is.fn(previous.then)) {\n\t                previous.then(this.release.bind(this, null));\n\t            }\n\t            return this;\n\t        }\n\t\n\t        /**\n\t         * Decrease locks for this store, if it reach 0 & it have a public state,\n\t         * it will be propagated to the followers,\n\t         * then, all stuff passed to \"then\" call back will be exec / released\n\t         * @param desync\n\t         * @returns {*}\n\t         */\n\t\n\t    }, {\n\t        key: 'release',\n\t        value: function release(reason, cb) {\n\t            var _this9 = this;\n\t\n\t            var _static = this.constructor;\n\t            var i = 0,\n\t                wasStable = this._stable;\n\t\n\t            if (is.fn(reason)) {\n\t                cb = reason;\n\t                reason = null;\n\t            }\n\t\n\t            if (reason) {\n\t                if (this.__locks[reason] == 0) console.error(\"Release more than locking !\", reason);\n\t                this.__locks[reason] = this.__locks[reason] || 0;\n\t                this.__locks[reason]--;\n\t            }\n\t\n\t            if (!reason && this.__locks.all == 0) console.error(\"Release more than locking !\");\n\t\n\t            if (! --this.__locks.all && this.data && this.isComplete()) {\n\t                this._stable = true;\n\t                this._rev++; //\n\t                if (this._followers.length) this._followers.forEach(function (follower) {\n\t                    var data = follower[2] ? _this9.retrieve(follower[2]) : _this9.data;\n\t                    if (!data) return;\n\t                    if (typeof follower[0] == \"function\") {\n\t                        follower[0](data);\n\t                    } else {\n\t                        //cb && i++;\n\t                        follower[0].setState(follower[1] ? _defineProperty({}, follower[1], data) : data\n\t                        //,\n\t                        //cb && (\n\t                        //    () => (!(--i) && cb())\n\t                        //)\n\t                        );\n\t                    }\n\t                });\n\t                //else\n\t                !wasStable && this.emit('stable', this.data);\n\t                this.emit('update', this.data);\n\t                cb && cb();\n\t            } else cb && this.then(cb);\n\t            return this;\n\t        }\n\t    }, {\n\t        key: 'retain',\n\t        value: function retain(reason) {\n\t            this.__retains.all++;\n\t            if (reason) {\n\t                this.__retains[reason] = this.__retains[reason] || 0;\n\t                this.__retains[reason]++;\n\t            }\n\t        }\n\t    }, {\n\t        key: 'dispose',\n\t        value: function dispose(reason) {\n\t            var _this10 = this;\n\t\n\t            //console.warn(\"dispose\", reason, this.__retains);\n\t            if (reason) {\n\t                if (!this.__retains[reason]) throw new Error(\"Dispose more than retaining : \" + reason);\n\t\n\t                this.__retains[reason]--;\n\t            }\n\t            if (this.__retains.all == 0) throw new Error(\"Dispose more than retaining !\");\n\t\n\t            this.__retains.all--;\n\t\n\t            if (!this.__retains.all) {\n\t                if (this._persistenceTm) {\n\t                    this._destroyTM && clearTimeout(this._destroyTM);\n\t                    this._destroyTM = setTimeout(function (e) {\n\t                        _this10._destroyTM = null;\n\t                        _this10.then(function (s) {\n\t                            !_this10.__retains.all && _this10.destroy();\n\t                        });\n\t                    }, this._persistenceTm);\n\t                } else {\n\t                    this.then(function (s) {\n\t                        return !_this10.__retains.all && _this10.destroy();\n\t                    });\n\t                }\n\t            }\n\t        }\n\t    }, {\n\t        key: 'destroy',\n\t        value: function destroy() {\n\t            //  console.log(\"destroy\", this._uid);\n\t\n\t            this.emit('destroy', this);\n\t            if (this._stabilizer) clearTimeout(this._stabilizer);\n\t\n\t            if (this._followers.length) this._followers.forEach(function (follower) {\n\t                if (typeof follower[0] !== \"function\") {\n\t                    if (follower[0].stores) delete follower[0].stores[follower[1]];\n\t                }\n\t            });\n\t            this._followers.length = 0;\n\t            this.constructor._rev = this.rev;\n\t            this.dead = true;\n\t            this._revs = this.data = this.state = this.scope = null;\n\t            this.removeAllListeners();\n\t        }\n\t    }, {\n\t        key: 'datas',\n\t\n\t\n\t        /**\n\t         * @deprecated\n\t         * @returns {*}\n\t         */\n\t        get: function get() {\n\t            return this.data;\n\t        }\n\t\n\t        /**\n\t         * @deprecated\n\t         * @returns {*}\n\t         */\n\t        ,\n\t        set: function set(v) {\n\t            //console.groupCollapsed(\"Rescope store : Setting datas is depreciated, use data\");\n\t            console.log(\"Rescope store : Setting datas is depreciated, use data\", new Error().stack);\n\t            //console.groupEnd();\n\t\n\t            this.data = v;\n\t        }\n\t    }], [{\n\t        key: 'as',\n\t        value: function as(name) {\n\t            return { store: this, name: name };\n\t        }\n\t\n\t        /**\n\t         * Map all named stores in {keys} to the {object}'s state\n\t         * Hook componentWillUnmount (for react comp) or destroy to unBind them automatically\n\t         * @static\n\t         * @param object {Object} target state aware object (React.Component|Store|...)\n\t         * @param keys {Array} Ex : [\"session\", \"otherStaticNamedStore:key\", store.as('anotherKey')]\n\t         */\n\t\n\t    }, {\n\t        key: 'map',\n\t        value: function map(component, keys, scope, origin) {\n\t            var setInitial = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\t\n\t            var targetRevs = component._revs || {};\n\t            var targetScope = component.stores || (component.stores = {});\n\t            var initialOutputs = {};\n\t            keys = is.array(keys) ? [].concat(_toConsumableArray(keys)) : [keys];\n\t\n\t            scope = scope || Store.staticScope;\n\t\n\t            keys = keys.filter(\n\t            // @todo : use query refs\n\t            // (store)(\\.store)*(\\[(\\*|(props)\\w+)+)\\])?(\\:alias)\n\t            function (key) {\n\t                if (!key) {\n\t                    console.error(\"Not a mappable store item '\" + key + \"' in \" + origin + ' !!');\n\t                    return false;\n\t                }\n\t                var name = void 0,\n\t                    alias = void 0,\n\t                    path = void 0,\n\t                    store = void 0;\n\t                if (key.store && key.name) {\n\t                    alias = name = key.name;\n\t                    store = key.store;\n\t                } else if (is.fn(key)) {\n\t                    name = alias = key.name || key.defaultName;\n\t                    store = key;\n\t                } else {\n\t                    key = key.match(/([\\w_]+)((?:\\.[\\w_]+)*)(?:\\:([\\w_]+))?/);\n\t                    name = key[1];\n\t                    path = key[2] && key[2].split('.').slice(1);\n\t                    store = scope.stores[key[1]];\n\t                    alias = key[3] || path && path[path.length - 1] || key[1];\n\t                }\n\t\n\t                if (targetRevs[name]) return false; // ignore dbl uses for now\n\t\n\t                if (!store) {\n\t                    console.error(\"Not a mappable store item '\" + name + \"/\" + alias + \"' in \" + origin + ' !!', store);\n\t                    return false;\n\t                } else if (is.fn(store)) {\n\t                    scope._mount(name);\n\t\n\t                    scope.stores[name].bind(component, alias, setInitial, path);\n\t                } else {\n\t                    store.bind(component, alias, setInitial, path);\n\t                }\n\t                targetRevs[alias] = targetRevs[alias] || true;\n\t                !targetScope[name] && (targetScope[name] = scope.stores[name]);\n\t                if (scope.stores[name].hasOwnProperty('data')) initialOutputs[name] = scope.data[name];\n\t                return true;\n\t            });\n\t            var mixedCWUnmount,\n\t                unMountKey = component.isReactComponent ? \"componentWillUnmount\" : \"destroy\";\n\t\n\t            if (component.hasOwnProperty(unMountKey)) {\n\t                mixedCWUnmount = component[unMountKey];\n\t            }\n\t\n\t            component[unMountKey] = function () {\n\t                delete component[unMountKey];\n\t                if (mixedCWUnmount) component[unMountKey] = mixedCWUnmount;\n\t\n\t                keys.map(function (key) {\n\t                    var name = void 0,\n\t                        alias = void 0,\n\t                        path = void 0,\n\t                        store = void 0;\n\t                    if (key.store && key.name) {\n\t                        alias = name = key.name;\n\t                        store = key.store;\n\t                    } else if (is.fn(key)) {\n\t                        name = alias = key.name || key.defaultName;\n\t                        store = scope.stores[name];\n\t                    } else {\n\t                        key = key.match(/([\\w_]+)((?:\\.[\\w_]+)*)(?:\\:([\\w_]+))?/);\n\t                        name = key[1];\n\t                        path = key[2] && key[2].split('.');\n\t                        store = scope.stores[key[1]];\n\t                        alias = key[3] || path && path[path.length - 1] || key[1];\n\t                    }\n\t\n\t                    store && !is.fn(store) && store.unBind(component, alias, path);\n\t                });\n\t                return component[unMountKey] && component[unMountKey].apply(component, arguments);\n\t            };\n\t\n\t            return initialOutputs;\n\t        }\n\t    }]);\n\t\n\t    return Store;\n\t}(EventEmitter);\n\t\n\tStore.use = [];\n\tStore.staticScope = new Scope({}, { id: \"static\" });\n\tStore.state = undefined;\n\tStore.persistenceTm = false;\n\texports.default = Store;\n\tmodule.exports = exports['default'];\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// dist/Rescope.nodeps.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 187e76790ed17b86fce4","/*\n * Copyright (c) 2018.  Caipi Labs.  All rights reserved.\n *\n * This File is part of Caipi. You can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *  This project is dual licensed under AGPL and Commercial Licence.\n *\n * @author : Nathanael Braun\n * @contact : caipilabs@gmail.com\n */\n\nimport Scope from \"./Scope\";\nimport Store from \"./Store\";\n\nScope.Store = Store;\n\nexport default { Store, Scope: Scope, Scope };\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/Rescope.js","module.exports = require(\"is\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"is\"\n// module id = 1\n// module chunks = 0","/*\n * Copyright (c)  2017 Caipi Labs .\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * @author : Nathanael Braun\n * @contact : caipilabs@gmail.com\n */\nvar is = require('is');\nexport default class Emitter {\n    _events = {};\n    \n    on( evt, cb ) {\n        if ( !is.string(evt) && evt )\n            return Object.keys(evt).forEach(k => this.on(k, evt[k]));\n        \n        this._events[evt] = this._events[evt] || [];\n        this._events[evt].push(cb);\n        \n    }\n    \n    un( evt, cb ) {\n        if ( !is.string(evt) && evt )\n            return Object.keys(evt).forEach(k => this.un(k, evt[k]));\n        \n        if ( !this._events[evt] ) return;\n        var i = this._events[evt].indexOf(cb);\n        this._events[evt].splice(i, 1);\n    }\n    \n    emit( evt, ...argz ) {\n        if ( !this._events[evt] ) return;\n        let lists = [...this._events[evt]];\n        for ( var i = 0; i < lists.length; i++ ) {\n            lists[i](...argz);\n        }\n    }\n    \n    addListener() {\n        this.on(...arguments);\n    }\n    \n    removeListener() {\n        this.un(...arguments);\n    }\n    \n    removeAllListeners() {\n        this._events = {};\n    }\n    \n    once( evt, cb ) {\n        let fn;\n        this.on(evt, fn = ( ...argz ) => {\n            this.un(evt, fn);\n            cb(...argz)\n        });\n    }\n    \n    \n}\n\n\n// WEBPACK FOOTER //\n// ./src/Emitter.js","/*\n * Copyright (c) 2018.  Caipi Labs.  All rights reserved.\n *\n * This File is part of Caipi. You can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *  This project is dual licensed under AGPL and Commercial Licence.\n *\n * @author : Nathanael Braun\n * @contact : caipilabs@gmail.com\n */\n\n\nvar is              = require('is'),\n    EventEmitter    = require('./Emitter'),\n    shortid         = require('shortid')\n    , __proto__push = ( target, id, parent ) => {\n        let fn           = function () {\n        };\n        fn.prototype     = parent ? new parent[\"_\" + id]() : target[id] || {};\n        target[id]       = new fn();\n        target['_' + id] = fn;\n    },\n    openScopes    = {};\n\n\nexport default class Scope extends EventEmitter {\n    static persistenceTm = 1;// if > 0, will wait 'persistenceTm' ms before destroy when dispose reach 0\n    static Store         = null;\n    static scopes      = openScopes;// all active scopes\n    \n    static getScope( scopes ) {\n        let skey = is.array(scopes) ? scopes.sort(( a, b ) => {\n            if ( a.firstname < b.firstname ) return -1;\n            if ( a.firstname > b.firstname ) return 1;\n            return 0;\n        }).join('::') : scopes;\n        return openScopes[skey] = openScopes[skey] || new Scope({}, { id: skey });\n    };\n    \n    /**\n     * Init a Rescope scope\n     *\n     * @param storesMap {Object} Object with the origin stores\n     * @param id {string} @optional id ( if this id exist storesMap will be merge on the 'id' scope)\n     * @param parent\n     * @param state\n     * @param data\n     * @param name\n     * @param defaultMaxListeners\n     * @param persistenceTm {number) if > 0, will wait 'persistenceTm' ms before destroy when dispose reach 0\n     * @param autoDestroy  {bool} will trigger retain & dispose after start\n     * @returns {Scope}\n     */\n    constructor( storesMap, { id, parent, state, data, name, incrementId, defaultMaxListeners, persistenceTm, autoDestroy, rootEmitter } = {} ) {\n        super();\n        \n        this._maxListeners = defaultMaxListeners || this.constructor.defaultMaxListeners;\n        id                 = id || (\"_____\" + shortid.generate());\n        if ( openScopes[id] && !incrementId ) {\n            this._id = id;\n            openScopes[id].register(storesMap);\n            return openScopes[id]\n        }\n        else if ( openScopes[id] && incrementId ) {\n            let i = -1;\n            while ( openScopes[id + '/' + (++i)] ) ;\n            id = id + '/' + i;\n        }\n        \n        this._id            = id;\n        openScopes[id]    = this;\n        this._isLocalId     = true;\n        this._persistenceTm = persistenceTm || this.constructor.persistenceTm;\n        \n        this.stores = {};\n        this.state  = {};\n        this.data   = {};\n        \n        if ( parent && parent.dead )\n            throw new Error(\"Can't use a dead scope as parent !\");\n        \n        __proto__push(this, 'stores', parent);\n        __proto__push(this, 'state', parent);\n        __proto__push(this, 'data', parent);\n        this.parent = parent;\n        \n        \n        this.sources            = [];\n        this._childScopes     = [];\n        this._childScopesList = [];\n        this._unStableChilds    = 0;\n        \n        this.__retains   = { all: 0 };\n        this.__locks     = { all: 1 };\n        this.__listening = {};\n        this.__scope   = {};\n        this.__mixed     = [];\n        this.__mixedList = [];\n        this._followers  = [];\n        if ( parent ) {\n            parent.retain(\"isMyParent\");\n            if ( !rootEmitter ) {\n                !parent._stable && this.wait(\"waitingParent\");\n                parent.on(this.__parentList = {\n                    'stable'  : s => this.release(\"waitingParent\"),\n                    'unstable': s => this.wait(\"waitingParent\"),\n                    'update'  : s => this._propag()\n                });\n            }\n            else {\n                parent.on(this.__parentList = {\n                    'update': s => this._propag()\n                });\n            }\n            // this.register(parent.__scope, state, data);\n        }\n        \n        \n        this.register(storesMap, state, data);\n        this.__locks.all--;\n        this._stable = !this.__locks.all;\n        \n        if ( parent ) {\n            parent._addChild(this);\n        }\n        if ( autoDestroy )\n            setTimeout(\n                tm => {\n                    this.retain(\"autoDestroy\");\n                    this.dispose(\"autoDestroy\");\n                }\n            )\n    }\n    \n    /**\n     * @deprecated\n     * @returns {*}\n     */\n    get datas() {\n        return this.data;\n    }\n    \n    /**\n     *\n     * Mount the stores in storesList, in this scope or in its parents or mixed scopes\n     *\n     * @param storesList {string|storeRef} Store name, Array of Store names, or Rescope store ref from Store::as or\n     *     Store:as\n     * @param state\n     * @param data\n     * @returns {Scope}\n     */\n    mount( storesList, state, data ) {\n        if ( is.array(storesList) ) {\n            storesList.forEach(k => this._mount(k, state && state[k], data && data[k]));\n        }\n        else {\n            this._mount(...arguments);\n        }\n        return this;\n    }\n    \n    _mount( id, state, data ) {\n        if ( typeof id !== 'string' ) {\n            this.register({ [id.name]: id.store });\n            id = id.name;\n        }\n        \n        if ( !this.__scope[id] ) {//ask mixed || parent\n            if ( this.__mixed.reduce(( mounted, ctx ) => (mounted || ctx._mount(id, state, data)), false) ||\n                !this.parent )\n                return;\n            return this.parent._mount(...arguments);\n        }\n        let store = this.__scope[id], ctx;\n        if ( is.fn(store) ) {\n            this.__scope[id] = new store(this, { state, data });\n        }\n        else {\n            if ( state !== undefined && data === undefined )\n                store.setState(state);\n            else if ( state !== undefined )\n                store.state = state;\n            \n            if ( data !== undefined )\n                store.push(data);\n        }\n        \n        \n        this._watchStore(id);\n        \n        return this.__scope[id];\n    }\n    \n    _watchStore( id, state, data ) {\n        if ( !this.__scope[id] ) {//ask mixed || parent\n            if ( this.__mixed.reduce(( mounted, ctx ) => (mounted || ctx._watchStore(id, state, data)), false) ||\n                !this.parent )\n                return;\n            return this.parent._watchStore(...arguments);\n        }\n        if ( !this.__listening[id] && !is.fn(this.__scope[id]) ) {\n            !this.__scope[id].isStable() && this.wait(id);\n            this.__scope[id].on(\n                this.__listening[id] = {\n                    'destroy' : s => {\n                        delete this.__listening[id];\n                        this.__scope[id] = this.__scope[id].constructor;\n                    },\n                    'update'  : s => this.propag(),\n                    'stable'  : s => this.release(id),\n                    'unstable': s => this.wait(id)\n                });\n        }\n        return true;\n    }\n    \n    /**\n     * Mix targetCtx on this scope\n     * Mixed scope parents are NOT mapped\n     * @param targetCtx\n     */\n    mixin( targetCtx ) {\n        let parent = this.parent, lists;\n        this.__mixed.push(targetCtx)\n        targetCtx.retain(\"mixedTo\");\n        if ( !targetCtx._stable )\n            this.wait(targetCtx._id);\n        \n        this.__mixedList.push(lists = {\n            'stable'  : s => this.release(targetCtx._id),\n            'unstable': s => this.wait(targetCtx._id),\n            'update'  : s => this._propag()\n        });\n        \n        this.stores = {};\n        this.state  = {};\n        this.data   = {};\n        targetCtx.on(lists);\n        __proto__push(this, 'stores', parent);\n        __proto__push(this, 'state', parent);\n        __proto__push(this, 'data', parent);\n        \n        this.relink(this.__scope, this, false, true);\n        this.__mixed.forEach(\n            ctx => {\n                __proto__push(this, 'stores');\n                __proto__push(this, 'state');\n                __proto__push(this, 'data');\n                ctx.relink(ctx.__scope, this, true, true)\n            }\n        )\n    }\n    \n    /**\n     * Register stores in storesMap & link them in the protos\n     * @param storesMap\n     * @param state\n     * @param data\n     */\n    register( storesMap, state = {}, data = {} ) {\n        this.relink(storesMap, this, false, false);\n        Object.keys(storesMap).forEach(\n            id => {\n                if ( storesMap[id].singleton || (is.fn(storesMap[id]) && (state[id] || data[id])) ) {\n                    this._mount(id, state[id], data[id])\n                }\n                else if ( state[id] || data[id] ) {\n                    if ( data[id] ) {\n                        if ( state[id] )\n                            this.stores[id].state = state[id];\n                        this.stores[id].push(data[id]);\n                    }\n                    else if ( state[id] ) {\n                        this.stores[id].setState(state[id]);\n                    }\n                }\n                else {\n                    this._watchStore(id);\n                }\n            }\n        )\n        \n    }\n    \n    /**\n     * Map srcCtx store's on targetCtx headers proto's\n     * @param srcCtx\n     * @param targetCtx\n     * @param state\n     * @param data\n     */\n    relink( srcCtx, targetCtx = this, external, force ) {\n        let lctx = targetCtx._stores.prototype;\n        Object.keys(srcCtx)\n              .forEach(\n                  id => {\n                      if ( !force && targetCtx.__scope[id] === srcCtx[id] ||\n                          targetCtx.__scope[id] && (targetCtx.__scope[id].constructor === srcCtx[id] ) )\n                          return;\n                \n                      if ( !force && targetCtx.__scope[id] ) {\n                          if ( !external && !is.fn(targetCtx.__scope[id]) ) {\n                              console.info(\"Rescope Store : \", id, \" already exist in this scope ! ( try __proto__ hot patch )\");\n                              targetCtx.__scope[id].__proto__ = srcCtx[id].prototype;\n                        \n                          }\n                          if ( !external && is.fn(targetCtx.__scope[id]) )\n                              targetCtx.__scope[id] = srcCtx[id];\n                    \n                          return;\n                      }\n                      else if ( !force && !external )\n                          this.__scope[id] = srcCtx[id];\n                \n                      Object.defineProperty(\n                          lctx,\n                          id,\n                          {\n                              get: () => this.__scope[id]\n                          }\n                      );\n                      Object.defineProperty(\n                          targetCtx._state.prototype,\n                          id,\n                          {\n                              get: () => (this.__scope[id] && this.__scope[id].state),\n                              set: ( v ) => (this._mount(id, v))\n                          }\n                      );\n                      Object.defineProperty(\n                          targetCtx._data.prototype,\n                          id,\n                          {\n                              get: () => (this.__scope[id] && this.__scope[id].data),\n                              set: ( v ) => (this._mount(id, undefined, v))\n                          }\n                      );\n                  }\n              )\n    }\n    \n    /**\n     * Bind stores from this scope, his parents and mixed scope\n     *\n     * @param obj {React.Component|Store|function}\n     * @param key {string} stores keys to bind updates\n     * @param as\n     * @param setInitial {bool} false to not propag initial value (default : true)\n     */\n    bind( obj, key, as, setInitial = true ) {\n        let lastRevs, data, reKey;\n        if ( key && !is.array(key) )\n            key = [key];\n        \n        if ( as === false || as === true ) {\n            setInitial = as;\n            as         = null;\n        }\n        \n        reKey = key.map(id => (is.string(id) ? id : id.name));\n        \n        this._followers.push(\n            [\n                obj,\n                key,\n                as || undefined,\n                lastRevs = reKey && reKey.reduce(( revs, id ) => (revs[id] = 0, revs), {})\n            ]);\n        \n        this.mount(key);\n        \n        if ( setInitial && this._stable ) {\n            data = this.getUpdates(lastRevs);\n            if ( !data ) return;\n            if ( typeof obj != \"function\" ) {\n                if ( as ) obj.setState({ [as]: data });\n                else obj.setState(data);\n            }\n            else {\n                obj(data);\n            }\n        }\n        return this;\n    }\n    \n    /**\n     * Un bind this scope off the given component-keys\n     * @param obj\n     * @param key\n     * @returns {Array.<*>}\n     */\n    unBind( obj, key, as ) {\n        var followers = this._followers,\n            i         = followers && followers.length;\n        while ( followers && i-- )\n            if ( followers[i][0] === obj && ('' + followers[i][1]) == ('' + key) &&\n                followers[i][2] == as )\n                return followers.splice(i, 1);\n    }\n    \n    /**\n     * Mount the stores in storesList from this scope, its parents and mixed scope\n     * Bind them to 'to'\n     * Hook 'to' so it will auto unbind on 'destroy' or 'componentWillUnmount'\n     * @param to\n     * @param storesList\n     * @param bind\n     * @returns {Object} Initial outputs of the stores in 'storesList'\n     */\n    map( to, storesList, bind = true ) {\n        let Store  = this.constructor.Store;\n        storesList = is.array(storesList) ? storesList : [storesList];\n        this.mount(storesList);\n        if ( bind && to instanceof Store ) {\n            Store.map(to, storesList, this, this, false)\n        }\n        else if ( bind ) {\n            this.bind(to, storesList, undefined, false);\n            \n            let mixedCWUnmount,\n                unMountKey = to.isReactComponent ? \"componentWillUnmount\" : \"destroy\";\n            \n            if ( to.hasOwnProperty(unMountKey) ) {\n                mixedCWUnmount = to[unMountKey];\n            }\n            \n            to[unMountKey] = ( ...argz ) => {\n                delete to[unMountKey];\n                if ( mixedCWUnmount )\n                    to[unMountKey] = mixedCWUnmount;\n                \n                this.unBind(to, storesList);\n                return to[unMountKey] && to[unMountKey](...argz);\n            }\n            \n        }\n        return storesList.reduce(( data, id ) => {\n            if ( !is.string(id) )\n                id = id.name;\n            id                                     = id.split(':');//@todo\n            id[0]                                  = id[0].split('.');\n            data[id[1] || id[0][id[0].length - 1]] = this.stores[id[0][0]] && this.stores[id[0][0]].retrieve && this.stores[id[0][0]].retrieve(id[0].splice(1));\n            return data;\n        }, {});\n    }\n    \n    retrieve( path = \"\" ) {\n        path = is.string(path) ? path.split('.') : path;\n        return path && this.stores[path[0]] &&\n            this.stores[path[0]].retrieve(path.splice(1));\n    }\n    \n    /**\n     * Get or update storesRevMap's revisions\n     * @param storesRevMap\n     * @param local\n     * @returns {{}}\n     */\n    getStoresRevs( storesRevMap = {}, local ) {\n        let ctx = this.__scope;\n        if ( !storesRevMap ) {\n            storesRevMap = {};\n        }\n        Object.keys(ctx).forEach(\n            id => {\n                if ( !is.fn(ctx[id])\n                ) {\n                    storesRevMap[id] = ctx[id]._rev;\n                }\n                else if ( !storesRevMap.hasOwnProperty(id) )\n                    storesRevMap[id] = false\n            }\n        );\n        if ( !local ) {\n            this.__mixed.reduce(( updated, ctx ) => (ctx.getStoresRevs(storesRevMap), storesRevMap), storesRevMap);\n            this.parent && this.parent.getStoresRevs(storesRevMap);\n        }\n        return storesRevMap;\n    }\n    \n    /**\n     * Get or update output basing storesRevMap's revisions.\n     * If a store in 'storesRevMap' is updated; add it to 'output'\n     * @param storesRevMap\n     * @param output\n     * @param updated\n     * @returns {*|{}}\n     */\n    getUpdates( storesRevMap, output, updated ) {\n        let ctx = this.__scope;\n        \n        output = output || {};\n        Object.keys(ctx).forEach(\n            id => {\n                if ( !output[id]\n                    && ( !storesRevMap\n                        || (storesRevMap.hasOwnProperty(id) && storesRevMap[id] === undefined)\n                        || !( !storesRevMap.hasOwnProperty(id) || ctx[id]._rev <= storesRevMap[id] ))\n                ) {\n                    \n                    updated    = true;\n                    output[id] = this.data[id];\n                    if ( storesRevMap && storesRevMap[id] !== undefined )\n                        storesRevMap[id] = ctx[id]._rev;\n                    \n                }\n            }\n        );\n        updated = this.__mixed.reduce(( updated, ctx ) => (ctx.getUpdates(storesRevMap, output, updated) || updated), updated);\n        updated = this.parent && this.parent.getUpdates(storesRevMap, output, updated) || updated;\n        return updated && output;\n    }\n    \n    /**\n     *\n     * @param flags_states\n     * @param flags_data\n     * @returns {{state: {}, data: {}}}\n     */\n    serialize( flags_states = /.*/, flags_data = /.*/ ) {\n        let ctx = this.__scope, output = { state: {}, data: {} },\n            _flags_states,\n            _flags_data;\n        if ( is.array(flags_states) )\n            flags_states.forEach(id => (output.state[id] = this.state[id]));\n        \n        if ( is.array(flags_data) )\n            flags_data.forEach(id => (output.data[id] = this.data[id]));\n        \n        if ( !is.array(flags_data) && !is.array(flags_states) )\n            Object.keys(ctx).forEach(\n                id => {\n                    if ( is.fn(ctx[id]) )\n                        return;\n                    \n                    let flags = ctx[id].constructor.flags;\n                    \n                    flags = is.array(flags) ? flags : [flags || \"\"];\n                    \n                    if ( flags.reduce(( r, flag ) => (r || flags_states.test(flag)), false) )\n                        output.state[id] = this.state[id];\n                    \n                    if ( flags.reduce(( r, flag ) => (r || flags_data.test(flag)), false) )\n                        output.data[id] = this.data[id];\n                }\n            )\n        return output;\n    }\n    \n    dispatch( action, data ) {\n        Object.keys(this.__scope)\n              .forEach(\n                  id => {\n                      if ( !is.fn(this.__scope[id]) )\n                          this.__scope[id].trigger(action, data)\n                  }\n              );\n        \n        this.__mixed.forEach(( ctx ) => (ctx.dispatch(action, data)));\n        this.parent && this.parent.dispatch(action, data);\n        return this;\n    }\n    \n    /**\n     * once('stable', cb)\n     * @param obj {React.Component|Store|function)\n     * @param key {string} optional key where to map the public state\n     */\n    then( cb ) {\n        if ( this._stable )\n            return cb(null, this.data);\n        this.once('stable', e => cb(null, this.data));\n    }\n    \n    restore( { state, data }, quiet ) {\n        let ctx = this.__scope;\n        Object.keys(data).forEach(\n            id => {\n                quiet ? ctx.data = data[id]\n                    : ctx.push(data[id]);\n            }\n        );\n        Object.keys(state).forEach(\n            id => {\n                quiet ? ctx.state = state[id]\n                    : ctx.setState(state[id]);\n            }\n        );\n    }\n    \n    retainStores( stores = [], reason ) {\n        stores.forEach(\n            id => (this.stores[id] && this.stores[id].retain && this.stores[id].retain(reason))\n        )\n    }\n    \n    disposeStores( stores = [], reason ) {\n        stores.forEach(\n            id => (this.stores[id] && this.stores[id].dispose && this.stores[id].dispose(reason))\n        )\n    }\n    \n    wait( reason ) {\n        //console.log(\"wait\", reason);\n        this._stable && !this.__locks.all && this.emit(\"unstable\", this);\n        this._stable = false;\n        this.__locks.all++;\n        if ( reason ) {\n            this.__locks[reason] = this.__locks[reason] || 0;\n            this.__locks[reason]++;\n        }\n    }\n    \n    release( reason ) {\n        \n        if ( reason ) {\n            if ( this.__locks[reason] == 0 )\n                console.error(\"Release more than locking !\", reason);\n            this.__locks[reason] = this.__locks[reason] || 0;\n            this.__locks[reason]--;\n        }\n        if ( !reason && this.__locks.all == 0 )\n            console.error(\"Release more than locking !\");\n        \n        this.__locks.all--;\n        if ( !this.__locks.all ) {\n            this._stabilizerTM && clearTimeout(this._stabilizerTM);\n            \n            this._stabilizerTM = setTimeout(\n                e => {\n                    this._stabilizerTM = null;\n                    if ( this.__locks.all )\n                        return;\n                    \n                    this._propagTM && clearTimeout(this._propagTM);\n                    \n                    this._stable = true;\n                    this.emit(\"stable\", this);\n                    \n                    !this.dead && this._propag();// stability can induce destroy\n                }\n            );\n        }\n        \n    }\n    \n    propag() {\n        this._propagTM && clearTimeout(this._propagTM);\n        this._propagTM = setTimeout(\n            e => {\n                this._propagTM = null;\n                this._propag()\n            }, 2\n        );\n    }\n    \n    _propag() {\n        if ( this._followers.length )\n            this._followers.forEach(( { 0: obj, 1: key, 2: as, 3: lastRevs } ) => {\n                let data = this.getUpdates(lastRevs);\n                if ( !data ) return;\n                if ( typeof obj != \"function\" ) {\n                    if ( as ) obj.setState({ [as]: data });\n                    else obj.setState(data);\n                }\n                else {\n                    obj(data, lastRevs && [...lastRevs] || \"no revs\");\n                }\n                // lastRevs &&\n                // key.forEach(id => (lastRevs[id] = this.stores[id] && this.stores[id]._rev || 0));\n            });\n        this.emit(\"update\", this.getUpdates());\n    }\n    \n    /**\n     * is stable\n     * @returns bool\n     */\n    isStable() {\n        return this._stable;\n    }\n    \n    //serializeChilds( childs = [] ) {\n    //\n    //}\n    \n    _addChild( ctx ) {\n        this._childScopes.push(ctx);\n        let lists     = {\n                'stable'      : s => {\n                    this._unStableChilds--;\n                    if ( !this._unStableChilds )\n                        this.emit(\"stableTree\", this)\n                },\n                'unstable'    : s => {\n                    this._unStableChilds++;\n                    if ( 1 == this._unStableChilds )\n                        this.emit(\"unstableTree\", this)\n                },\n                'stableTree'  : s => {\n                    this._unStableChilds--;\n                    if ( !this._unStableChilds )\n                        this.emit(\"stableTree\", this)\n                },\n                'unstableTree': s => {\n                    this._unStableChilds++;\n                    if ( 1 == this._unStableChilds )\n                        this.emit(\"unstableTree\", this)\n                },\n                'destroy'     : ctx => {\n                    if ( ctx._unStableChilds )\n                        this._unStableChilds--;\n                    if ( !ctx.isStable() )\n                        this._unStableChilds--;\n                \n                    if ( !this._unStableChilds )\n                        this.emit(\"stableTree\", this)\n                }\n            },\n            wasStable = this._unStableChilds;\n        //!ctx.isStable() && console.warn('add unstable child');\n        !ctx.isStable() && this._unStableChilds++;\n        ctx._unStableChilds && this._unStableChilds++;\n        this._childScopesList.push(lists);\n        if ( !wasStable && this._unStableChilds )\n            this.emit(\"unstableTree\", this)\n        ctx.on(lists);\n    }\n    \n    _rmChild( ctx ) {\n        let i         = this._childScopes.indexOf(ctx),\n            wasStable = this._unStableChilds;\n        if ( i != -1 ) {\n            this._childScopes.splice(i, 1);\n            !ctx.isStable() && this._unStableChilds--;\n            ctx._unStableChilds && this._unStableChilds--;\n            ctx.un(this._childScopesList.splice(i, 1)[0]);\n            if ( wasStable && !this._unStableChilds )\n                this.emit(\"stableTree\")\n        }\n    }\n    \n    retain( reason ) {\n        this.__retains.all++;\n        //console.log(\"retain\", this._id, reason);\n        if ( reason ) {\n            this.__retains[reason] = this.__retains[reason] || 0;\n            this.__retains[reason]++;\n        }\n    }\n    \n    dispose( reason ) {\n        //console.log(\"dispose\", this._id, reason);\n        if ( reason ) {\n            if ( !this.__retains[reason] )\n                throw new Error(\"Dispose more than retaining : \" + reason);\n            this.__retains[reason]--;\n        }\n        \n        if ( !this.__retains.all )\n            throw new Error(\"Dispose more than retaining !\");\n        \n        this.__retains.all--;\n        \n        if ( !this.__retains.all ) {\n            //console.log(\"dispose do destroy \", this._id, this._persistenceTm);\n            if ( this._persistenceTm ) {\n                this._destroyTM && clearTimeout(this._destroyTM);\n                this._destroyTM = setTimeout(\n                    e => {\n                        this.then(s => {\n                            !this.__retains.all && this.destroy()\n                        });\n                    },\n                    this._persistenceTm\n                );\n            }\n            else {\n                this.then(s => (!this.__retains.all && this.destroy()));\n            }\n        }\n    }\n    \n    /**\n     * order destroy of local stores\n     */\n    destroy() {\n        let ctx   = this.__scope;\n        //console.warn(\"destroy\", this._id);\n        this.dead = true;\n        this.emit(\"destroy\", this);\n        Object.keys(\n            this.__listening\n        ).forEach(\n            id => this.__scope[id].removeListener(this.__listening[id])\n        );\n        \n        this._stabilizerTM && clearTimeout(this._stabilizerTM);\n        this._propagTM && clearTimeout(this._propagTM);\n        this.__listening = {};\n        \n        if ( this._isLocalId )\n            delete openScopes[this._id];\n        this._followers.length = 0;\n        \n        while ( this.__mixedList.length ) {\n            this.__mixed[0].removeListener(this.__mixedList.shift());\n            this.__mixed.shift().dispose(\"mixedTo\");\n        }\n        if ( this.__parentList ) {\n            this.parent._rmChild(this);\n            this.parent.removeListener(this.__parentList);\n            this.parent.dispose(\"isMyParent\");\n            this.__parentList = null;\n        }\n        //for ( let key in ctx )\n        //    if ( !is.fn(ctx[key]) ) {\n        //        if ( ctx[key].scopeObj === this )\n        //            ctx[key].dispose();\n        //\n        //        ctx[key] = ctx[key].constructor;\n        //    }\n        this.__mixed = this.data = this.state = this.scope = this.stores = null;\n        this._data = this._state = this._stores = null;\n        \n        \n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/Scope.js","module.exports = require(\"shortid\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"shortid\"\n// module id = 4\n// module chunks = 0","/*\n * Copyright (c)  2017 Caipi Labs .\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * @author : Nathanael Braun\n * @contact : caipilabs@gmail.com\n */\n\n/**\n * Ultra scalable state-aware store\n *\n * @todo : lot of optims...\n */\n\nvar is           = require('is'),\n    Scope        = require('./Scope'),\n    EventEmitter = require('./Emitter'),\n    shortid      = require('shortid'),\n    objProto     = Object.getPrototypeOf({});\n/**\n * @class Store\n */\nexport default class Store extends EventEmitter {\n    \n    static use                  = [];// overridable list of source stores\n    static follow;// overridable list of store that will allow push if updated\n    static require;\n    static staticScope          = new Scope({}, { id: \"static\" });\n    static state                = undefined;// default state\n    /**\n     * if retain goes to 0 :\n     * false to not destroy,\n     * 0 to sync auto destroy\n     * Ms to autodestroy after tm ms if no retain has been called\n     * @type {boolean|Int}\n     */\n           static persistenceTm = false;\n    \n    /**\n     * Constructor, will build a rescope store\n     *\n     * (scope, {require,use,apply,state, data})\n     * (scope)\n     *\n     * @param scope {object} scope where to find the other stores (default : static staticScope )\n     * @param keys {Array} (passed to Store::map) Ex : [\"session\", \"otherNamedStore:key\", otherStore.as(\"otherKey\")]\n     */\n    constructor() {\n        super();\n        var argz         = [...arguments],\n            _static      = this.constructor,\n            scope      = argz[0] instanceof Scope\n                ? argz.shift()\n                : _static.scope ? Scope.getScope(_static.scope)\n                               : is.string(argz[0])\n                      ? Scope.getScope(argz.shift())\n                      : _static.staticScope,\n            cfg          = argz[0] && !is.array(argz[0]) && !is.string(argz[0]) ? argz.shift() : {},\n            name         = is.string(argz[0]) ? argz[0] : cfg.name || _static.name,\n            watchs       = is.array(argz[0]) ? argz.shift() : cfg.use || [],// watchs need to be defined after all the\n                                                                            // store are registered : so we can't deal\n                                                                            // with any \"static use\" automaticly\n            apply        = is.fn(argz[0]) ? argz.shift() : cfg.apply || null,\n            initialState = _static.state || _static.initialState,\n            applied;\n        \n        this._uid = cfg._uid || shortid.generate();\n        \n        this.__retains    = { all: 0 };\n        this.__locks      = { all: 0 };\n        this._onStabilize = [];\n        \n        this._persistenceTm = cfg.persistenceTm || this.constructor.persistenceTm;\n        if ( is.string(argz[0]) ) {\n            if ( scope.__scope[name] )\n                console.warn(\"ReScope: Overwriting an existing static named store ( %s ) !!\", name);\n            scope.__scope[name] = this;\n        }\n        \n        if ( cfg && cfg.on ) {\n            this.on(cfg.on);\n        }\n        // this.state      = this.state || {};\n        \n        \n        this.name = name;\n        \n        if ( scope.stores ) {\n            this.scopeObj = scope;\n            this.scope    = scope.stores;\n        }\n        else {\n            this.scopeObj = new Scope(scope);\n            this.scope    = scope.stores;\n        }\n        \n        \n        this._rev     = this.constructor._rev || 0;\n        this._revs    = {};\n        this.stores   = {};\n        this._require = [];\n        \n        if ( is.array(_static.use) ) {\n            this._use = [...watchs, ...(_static.use || []).map(\n                key => {\n                    let ref = key.match(/^(\\!?)([^\\:]*)(?:\\:(.*))?$/);\n                    if ( ref[1] ) {\n                        let ref2 = ref[2].split('.');\n                        this._require.push(ref[3] || ref2[ref2.length - 1]);\n                    }\n                    return ref[2];\n                }\n            )];\n        }\n        else {\n            this._use = [...watchs, ...(\n                _static.use ? Object.keys(_static.use)\n                                    .map(\n                                        key => {\n                                            let ref = key.match(/^(\\!?)(.*)$/);\n                                            ref[1] && this._require.push(_static.use[key]);\n                                            return ref[2] + ((_static.use[key] === true)\n                                                ? ''\n                                                : ':' + _static.use[key]);\n                                        }\n                                    ) : []\n            )];\n        }\n        \n        if ( _static.require )\n            this._require.push(..._static.require);\n        if ( cfg.require )\n            this._require.push(...cfg.require);\n        \n        this._followers = [];\n        \n        if ( _static.data !== undefined )\n            this.data = { ..._static.data };\n        if ( cfg.hasOwnProperty(\"data\") && cfg.data !== undefined )\n            this.data = cfg.data;\n        if ( cfg.hasOwnProperty(\"state\") && cfg.state !== undefined )\n            initialState = { ...initialState, ...cfg.state };\n        \n        if ( apply )\n            this.apply = apply;\n        \n        \n        if ( initialState || this._use.length ) {// sync apply\n            this.state = {\n                ...(initialState || {}),\n                ...scope.map(this, this._use)\n            };\n            if ( this.shouldApply(this.state) && this.data === undefined ) {\n                this.data = this.apply(this.data, this.state, this.state);\n                applied   = true;\n            }\n        }\n        \n        if ( (this.data !== undefined || applied) && !this.__locks.all ) {\n            this._stable = true;\n            this._rev++;\n        }\n        else {\n            this._stable = false;\n            if ( !_static.managed && !this.state && (!this._use || !this._use.length) ) {\n                console.warn(\"Rescope store '\", this.name, \"' have no initial data, state or use. It can't stabilize...\");\n            }\n        }\n        !this._stable && this.emit('unstable', this.state);\n    }\n    \n    /**\n     * get a Builder-key pair for Store::map\n     * @param {string} name\n     * @returns {{store: Store, name: *}}\n     */\n    static as( name ) {\n        return { store: this, name };\n    }\n    \n    /**\n     * Map all named stores in {keys} to the {object}'s state\n     * Hook componentWillUnmount (for react comp) or destroy to unBind them automatically\n     * @static\n     * @param object {Object} target state aware object (React.Component|Store|...)\n     * @param keys {Array} Ex : [\"session\", \"otherStaticNamedStore:key\", store.as('anotherKey')]\n     */\n    static map( component, keys, scope, origin, setInitial = false ) {\n        var targetRevs     = component._revs || {};\n        var targetScope    = component.stores || (component.stores = {});\n        var initialOutputs = {};\n        keys               = is.array(keys) ? [...keys] : [keys];\n        \n        \n        scope = scope || Store.staticScope;\n        \n        keys           = keys.filter(\n            // @todo : use query refs\n            // (store)(\\.store)*(\\[(\\*|(props)\\w+)+)\\])?(\\:alias)\n            ( key ) => {\n                if ( !key ) {\n                    console.error(\"Not a mappable store item '\" + key + \"' in \" + origin + ' !!');\n                    return false;\n                }\n                let name,\n                    alias,\n                    path,\n                    store;\n                if ( key.store && key.name ) {\n                    alias = name = key.name;\n                    store = key.store;\n                }\n                else if ( is.fn(key) ) {\n                    name = alias = key.name || key.defaultName;\n                    store = key;\n                }\n                else {\n                    key   = key.match(/([\\w_]+)((?:\\.[\\w_]+)*)(?:\\:([\\w_]+))?/);\n                    name  = key[1];\n                    path  = key[2] && key[2].split('.').slice(1);\n                    store = scope.stores[key[1]];\n                    alias = key[3] || path && path[path.length - 1] || key[1];\n                }\n                \n                if ( targetRevs[name] ) return false;// ignore dbl uses for now\n                \n                if ( !store ) {\n                    console.error(\"Not a mappable store item '\" + name + \"/\" + alias + \"' in \" + origin + ' !!', store);\n                    return false;\n                }\n                else if ( is.fn(store) ) {\n                    scope._mount(name)\n                    \n                    scope.stores[name].bind(component, alias, setInitial, path);\n                }\n                else {\n                    store.bind(component, alias, setInitial, path);\n                }\n                targetRevs[alias] = targetRevs[alias] || true;\n                !targetScope[name] && (targetScope[name] = scope.stores[name]);\n                if ( scope.stores[name].hasOwnProperty('data') )\n                    initialOutputs[name] = scope.data[name];\n                return true;\n            }\n        );\n        var mixedCWUnmount,\n            unMountKey = component.isReactComponent ? \"componentWillUnmount\" : \"destroy\";\n        \n        if ( component.hasOwnProperty(unMountKey) ) {\n            mixedCWUnmount = component[unMountKey];\n        }\n        \n        component[unMountKey] = ( ...argz ) => {\n            delete component[unMountKey];\n            if ( mixedCWUnmount )\n                component[unMountKey] = mixedCWUnmount;\n            \n            keys.map(\n                ( key ) => {\n                    let name,\n                        alias, path,\n                        store;\n                    if ( key.store && key.name ) {\n                        alias = name = key.name;\n                        store = key.store;\n                    }\n                    else if ( is.fn(key) ) {\n                        name = alias = key.name || key.defaultName;\n                        store = scope.stores[name];\n                    }\n                    else {\n                        key   = key.match(/([\\w_]+)((?:\\.[\\w_]+)*)(?:\\:([\\w_]+))?/);\n                        name  = key[1];\n                        path  = key[2] && key[2].split('.');\n                        store = scope.stores[key[1]];\n                        alias = key[3] || path && path[path.length - 1] || key[1];\n                    }\n                    \n                    store && !is.fn(store) && store.unBind(component, alias, path)\n                }\n            );\n            return component[unMountKey] && component[unMountKey](...argz);\n        }\n        \n        return initialOutputs;\n    }\n    \n    /**\n     * @deprecated\n     * @returns {*}\n     */\n    get datas() {\n        return this.data;\n    }\n    \n    /**\n     * @deprecated\n     * @returns {*}\n     */\n    set datas( v ) {\n        //console.groupCollapsed(\"Rescope store : Setting datas is depreciated, use data\");\n        console.log(\"Rescope store : Setting datas is depreciated, use data\", (new Error()).stack);\n        //console.groupEnd();\n        \n        this.data = v;\n    }\n    \n    /**\n     * Overridable method to know if a data change should be propag to the listening stores & components\n     */\n    shouldPropag( nDatas ) {\n        var _static = this.constructor, r,\n            cDatas  = this.data;\n        r           = !cDatas && nDatas;\n        cDatas && Object.keys(cDatas).forEach(\n            ( key ) => {\n                r = r || (nDatas ? cDatas[key] !== nDatas[key] : cDatas && cDatas[key])\n            }\n        );\n        nDatas && Object.keys(nDatas).forEach(\n            ( key ) => {\n                r = r || (nDatas ? cDatas[key] !== nDatas[key] : cDatas && cDatas[key])\n            }\n        );\n        return !!r;\n    }\n    \n    /**\n     * Overridable method to know if a state change should be applied\n     */\n    shouldApply( state = this.state ) {\n        var _static = this.constructor;\n        \n        return (\n            !!this.isComplete(state)\n        ) && (is.array(_static.follow)\n                ? _static.follow\n                         .reduce(( r, i ) => (r || state && state[i]), false)\n                : _static.follow\n                  ? Object.keys(_static.follow)\n                          .reduce(( r, i ) => (\n                              r\n                              || state && is.fn(_static.follow[i]) && _static.follow[i].call(this, state[i])\n                              || _static.follow[i] && state[i] !== this.state[i]\n                          ), false) : true\n        );\n    }\n    \n    /**\n     * Overridable applier / remapper\n     * If state or lastPublicState are simple hash maps apply will return {...data, ...state}\n     * if not it will return the last private state\n     * @param data\n     * @param state\n     * @returns {*}\n     */\n    apply( data, state, changes ) {\n        state = state || this.state;\n        \n        if ( this.refine )\n            return this.refine(...arguments);\n        \n        if ( !data || data.__proto__ !== objProto || state.__proto__ !== objProto )\n            return state;\n        else\n            return { ...data, ...state }\n    }\n    \n    /**\n     * @depreciated\n     * @param data\n     * @param state\n     * @param changes\n     * @returns {*}\n     */\n    refine( data, state, changes ) {\n        state = state || this.state;\n        \n        if ( !data || data.__proto__ !== objProto || state.__proto__ !== objProto )\n            return state;\n        else\n            return { ...data, ...state }\n    }\n    \n    /**\n     * Debounce this store propagation ( & reducing )\n     * @param cb\n     */\n    stabilize( cb ) {\n        cb && this.once('stable', cb);\n        this._stable && this.emit('unstable', this.state, this.data);\n        \n        this._stable = false;\n        \n        if ( this._stabilizer )\n            clearTimeout(this._stabilizer);\n        \n        this._stabilizer = setTimeout(\n            this.push.bind(\n                this,\n                null,\n                () => {//@todo\n                    \n                    let stable   = this._stable;\n                    this._stable = true;\n                    !stable && this.emit('stable', this.state, this.data);\n                    this._stabilizer = null;\n                    // this.release();\n                }\n            ));\n    }\n    \n    retrieve( path, i = 0, obj = this.data ) {\n        path = is.string(path) ? path.split('.') : path;\n        return !obj || !path || !path.length\n            ? obj\n            : path.length == i + 1\n                   ? obj[path[i]]\n                   : this.retrieve(path, i + 1, obj[path[i]]);\n    }\n    \n    dispatch( action, ...argz ) {\n        this.scopeObj.dispatch(action, ...argz);\n    }\n    \n    trigger( action, ...argz ) {\n        let { actions } = this.constructor,\n            ns;\n        if ( actions && actions[action] ) {\n            ns = actions[action].call(this, ...argz);\n            ns && this.setState(ns);\n        }\n    }\n    \n    /**\n     * Pull stores in the private state\n     * @param stores  {Array} (passed to Store::map) Ex : [\"session\", \"otherNamedStore:key\", otherStore.as(\"otherKey\")]\n     */\n    pull( stores, doWait, origin ) {\n        let initialOutputs = this.scopeObj.map(this, stores);\n        if ( doWait ) {\n            this.wait();\n            stores.forEach(( s ) => this.scope[s] && this.wait(this.scope[s]));\n            this.release();\n        }\n        return initialOutputs;\n    }\n    \n    /**\n     * Apply apply/remap on the private state & push the resulting \"public\" state to followers\n     * @param cb\n     */\n    push( data, force, cb ) {\n        cb            = force === true ? cb : force;\n        force         = force === true;\n        var i         = 0,\n            nextState = !data && { ...this.state, ...this._changesSW } || this.state,\n            nextDatas = data || this.apply(this.data, nextState, this._changesSW);\n        \n        this.state = nextState;\n        if ( !force &&\n            (\n                (!this.data && this.data === nextDatas) || !this.shouldPropag(nextDatas)\n            )\n        ) {\n            cb && cb();\n            return false;\n        }\n        \n        this.data       = nextDatas;\n        this._changesSW = {};\n        //this.__locks.all++;\n        this.wait();\n        this.release(cb);\n        \n    }\n    \n    /**\n     * Update the current private state & push it once the store is stable\n     * @param pState\n     * @param cb\n     */\n    setState( pState, cb, sync ) {\n        var i       = 0, change,\n            changes = this._changesSW = this._changesSW || {};\n        for ( var k in pState )\n            if ( !this.state || pState.hasOwnProperty(k)\n                && (\n                    pState[k] != this.state[k]\n                    ||\n                    (this.state[k] && pState[k] && (pState[k]._rev != this._revs[k]))// rev/hash update\n                ) ) {\n                change        = true;\n                this._revs[k] = pState[k] && pState[k]._rev || true;\n                changes[k]    = pState[k];\n            }\n        \n        if ( !this.shouldApply({ ...this.state, ...changes }) ) {\n            return;\n        }\n        \n        if ( sync ) {\n            this.push();\n            cb && cb();\n            \n        }\n        else {\n            if ( change ) {\n                this.stabilize(cb);\n            }\n            else cb && cb();\n        }\n        return this;\n    }\n    \n    /**\n     * Update the current private state & push it once the store is stable\n     * @param pState\n     * @param cb\n     */\n    setStateSync( pState ) {\n        var i       = 0, change,\n            changes = this._changesSW = this._changesSW || {};\n        for ( var k in pState )\n            if ( !this.state || pState.hasOwnProperty(k)\n                && (\n                    pState[k] != this.state[k]\n                    ||\n                    (this.state[k] && pState[k] && (pState[k]._rev != this._revs[k]))// rev/hash update\n                ) ) {\n                change        = true;\n                this._revs[k] = pState[k] && pState[k]._rev || true;\n                changes[k]    = pState[k];\n            }\n        this.shouldApply({ ...(this.state || {}), ...changes }) && this.push();\n        return this.data;\n    }\n    \n    /**\n     * Replace the current private state & push it once the store is stable\n     * @param pState\n     * @param cb\n     */\n    replaceState( pState, cb ) {\n        var i      = 0, me = this;\n        this.state = pState;\n        \n        this.stabilize(cb);\n    }\n    \n    /**\n     * get a store-key pair for Store::map\n     * @param {string} name\n     * @returns {{store: Store, name: *}}\n     */\n    as( name ) {\n        return { store: this, name };\n    }\n    \n    on( lists ) {\n        if ( !is.string(lists) && lists )\n            Object.keys(lists).forEach(k => super.on(k, lists[k]));\n        else super.on(...arguments);\n    }\n    \n    removeListener( lists ) {\n        if ( !is.string(lists) && lists )\n            Object.keys(lists).forEach(k => super.removeListener(k, lists[k]));\n        else super.removeListener(...arguments);\n    }\n    \n    /**\n     * relink bindings & requires\n     * @param {string} name\n     * @returns {{store: Store, name: *}}\n     */\n    relink( from ) {\n        let scope = this.scopeObj,\n            _static = this.constructor;\n        if ( _static.use ) {\n            //todo unlink\n            this.pull(_static.use, false, from);\n        }\n        \n        if ( this._require ) {\n            this._require.forEach(\n                store => (\n                    this.wait(scope.__scope[store])\n                )\n            );\n        }\n    }\n    \n    /**\n     * is complete (all requiered keys are here)\n     * @returns bool\n     */\n    isComplete( state = this.state ) {\n        var _static = this.constructor;\n        return (\n            !this._require\n            || !this._require.length\n            || state && this._require.reduce(\n                ( r, key ) => (r && state[key]),\n                true\n            )\n        );\n    }\n    \n    /**\n     * is stable\n     * @returns bool\n     */\n    isStable() {\n        return this._stable;\n    }\n    \n    /**\n     * Un bind this store off the given component-key\n     * @param obj\n     * @param key\n     * @returns {Array.<*>}\n     */\n    unBind( obj, key, path ) {\n        var followers = this._followers,\n            i         = followers && followers.length;\n        while ( followers && i-- )\n            if ( followers[i][0] === obj && followers[i][1] === key && followers[i][2] === path )\n                return followers.splice(i, 1);\n    }\n    \n    /**\n     * Bind this store changes to the given component-key\n     * @param obj {React.Component|Store|function)\n     * @param key {string} optional key where to map the public state\n     */\n    bind( obj, key, setInitial = true, path ) {\n        this._followers.push([obj, key, path]);\n        if ( setInitial && this.data && this._stable ) {\n            let data = path ? this.retrieve(path) : this.data;\n            if ( typeof obj != \"function\" ) {\n                if ( key ) obj.setState({ [key]: data });\n                else obj.setState(data);\n            }\n            else {\n                obj(data);\n            }\n        }\n    }\n    \n    /**\n     * once('stable', cb)\n     * @param obj {React.Component|Store|function)\n     * @param key {string} optional key where to map the public state\n     */\n    then( cb ) {\n        if ( this._stable )\n            return cb(null, this.data);\n        this.once('stable', e => cb(null, this.data));\n    }\n    \n    /**\n     * Add a lock so the store will not propag it state untill release() is call\n     * @param previous {Store|number|Array} @optional wf to wait, releases to wait or array of stuff to wait\n     * @returns {TaskFlow}\n     */\n    wait( previous ) {\n        if ( typeof previous == \"number\" )\n            return this.__locks.all += previous;\n        if ( is.array(previous) )\n            return previous.map(this.wait.bind(this));\n        \n        this._stable && this.emit('unstable', this.state, this.data);\n        this._stable = false;\n        this.__locks.all++;\n        \n        let reason = is.string(previous) ? previous : null;\n        if ( reason ) {\n            this.__locks[reason] = this.__locks[reason] || 0;\n            this.__locks[reason]++;\n        }\n        if ( previous && is.fn(previous.then) ) {\n            previous.then(this.release.bind(this, null));\n        }\n        return this;\n    }\n    \n    /**\n     * Decrease locks for this store, if it reach 0 & it have a public state,\n     * it will be propagated to the followers,\n     * then, all stuff passed to \"then\" call back will be exec / released\n     * @param desync\n     * @returns {*}\n     */\n    release( reason, cb ) {\n        var _static = this.constructor;\n        let i       = 0, wasStable = this._stable;\n        \n        if ( is.fn(reason) ) {\n            cb     = reason;\n            reason = null;\n        }\n        \n        if ( reason ) {\n            if ( this.__locks[reason] == 0 )\n                console.error(\"Release more than locking !\", reason);\n            this.__locks[reason] = this.__locks[reason] || 0;\n            this.__locks[reason]--;\n        }\n        \n        if ( !reason && this.__locks.all == 0 )\n            console.error(\"Release more than locking !\");\n        \n        if ( !--this.__locks.all && this.data && this.isComplete() ) {\n            this._stable = true;\n            this._rev++;//\n            if ( this._followers.length )\n                this._followers.forEach(( follower ) => {\n                    let data = follower[2] ? this.retrieve(follower[2]) : this.data;\n                    if ( !data ) return;\n                    if ( typeof follower[0] == \"function\" ) {\n                        follower[0](data);\n                    }\n                    else {\n                        //cb && i++;\n                        follower[0].setState(\n                            (follower[1]) ? { [follower[1]]: data }\n                                : data\n                            //,\n                            //cb && (\n                            //    () => (!(--i) && cb())\n                            //)\n                        );\n                    }\n                });\n            //else\n            !wasStable && this.emit('stable', this.data);\n            this.emit('update', this.data);\n            cb && cb()\n        }\n        else cb && this.then(cb);\n        return this;\n    }\n    \n    retain( reason ) {\n        this.__retains.all++;\n        if ( reason ) {\n            this.__retains[reason] = this.__retains[reason] || 0;\n            this.__retains[reason]++;\n        }\n    }\n    \n    dispose( reason ) {\n        //console.warn(\"dispose\", reason, this.__retains);\n        if ( reason ) {\n            if ( !this.__retains[reason] )\n                throw new Error(\"Dispose more than retaining : \" + reason);\n            \n            this.__retains[reason]--;\n        }\n        if ( this.__retains.all == 0 )\n            throw new Error(\"Dispose more than retaining !\");\n        \n        this.__retains.all--;\n        \n        if ( !this.__retains.all ) {\n            if ( this._persistenceTm ) {\n                this._destroyTM && clearTimeout(this._destroyTM);\n                this._destroyTM = setTimeout(\n                    e => {\n                        this._destroyTM = null;\n                        this.then(s => {\n                            !this.__retains.all && this.destroy()\n                        });\n                    },\n                    this._persistenceTm\n                );\n            }\n            else {\n                this.then(s => (!this.__retains.all && this.destroy()));\n            }\n        }\n    }\n    \n    destroy() {\n        //  console.log(\"destroy\", this._uid);\n        \n        this.emit('destroy', this);\n        if ( this._stabilizer )\n            clearTimeout(this._stabilizer);\n        \n        if ( this._followers.length )\n            this._followers.forEach(\n                ( follower ) => {\n                    if ( typeof follower[0] !== \"function\" ) {\n                        if ( follower[0].stores )\n                            delete follower[0].stores[follower[1]];\n                    }\n                }\n            );\n        this._followers.length = 0;\n        this.constructor._rev  = this.rev;\n        this.dead              = true;\n        this._revs             = this.data = this.state = this.scope = null;\n        this.removeAllListeners();\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/Store.js"],"sourceRoot":""}
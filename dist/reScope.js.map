{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"is\"","webpack:///external \"@babel/runtime/helpers/toConsumableArray\"","webpack:///./src/utils/utils.js","webpack:///external \"@babel/runtime/helpers/defineProperty\"","webpack:///external \"@babel/runtime/helpers/assertThisInitialized\"","webpack:///external \"@babel/runtime/helpers/getPrototypeOf\"","webpack:///external \"@babel/runtime/helpers/createClass\"","webpack:///external \"@babel/runtime/helpers/classCallCheck\"","webpack:///external \"@babel/runtime/helpers/possibleConstructorReturn\"","webpack:///external \"@babel/runtime/helpers/get\"","webpack:///external \"@babel/runtime/helpers/inherits\"","webpack:///external \"shortid\"","webpack:///./src/utils/Emitter.js","webpack:///./src/Scope.js","webpack:///./src/index.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/Store.js","webpack:///./src/utils/TaskSequencer.js","webpack:///./node_modules/process/browser.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","is","walknSet","obj","path","stack","string","split","length","slice","walknGet","isKey","keyWalknSet","filter","v","keyWalknGet","Emitter","_events","evt","cb","keys","forEach","k","on","this","push","un","indexOf","splice","lists","argz","arguments","fn","__proto__push","target","id","parent","_","allScopes","Scope","storesMap","upperScope","snapshot","state","data","incrementId","persistenceTm","autoDestroy","rootEmitter","boundedActions","keyPID","_id","shortid","generate","baseId","isLocalId","register","_rev","actions","stores","_autoDestroy","constructor","dead","Error","sources","childScopes","childScopesList","unStableChilds","seenChilds","_listening","_scope","_mixed","_mixedList","followers","__retains","all","__locks","_boundedActions","array","test","includes","retain","_parentList","_propag","_stable","wait","release","_addChild","restore","setTimeout","tm","dispose","sm","applier","_refs","cpath","scopeRef","Function","Store","as","scopes","skey","sort","a","b","firstname","join","storeIdList","storeId","_mount","ref","parseRef","reduceRight","mounted","ctx","store","taskQueue","isStoreClass","shift","isScopeClass","$parent","mount","isStore","undefined","setState","isScope","_watchStore","relink","singleton","srcCtx","targetCtx","external","force","activeActions","__proto__","_storeHasBeenHotSwitched","configurable","set","act","__targetStores","dispatch","hotReloading","isStable","propag","__origin","lastRevs","refKeys","setInitial","revMap","map","reduce","revs","rev","refs","retainStores","getUpdates","disposeStores","refList","mixedCWUnmount","unMountKey","isReactComponent","unBind","alias","retrieve","cScope","retrieveStore","storesRevMap","local","updated","getStoresRevs","_getRevMap","output","childs","_getAllChilds","cfg","parentAlias","sid","serialize_ex","exclude","withChilds","withMixed","norefs","serialize","withChild","withParents","h","snap","bool","takeSnapshotByKey","destroy","startsWith","substr","getSnapshotByKey","deleteSnapshotByKey","replace","pState","_ref","action","bActs","trigger","console","warn","once","e","then","onceStableTree","reason","emit","error","stabilizerTM","clearTimeout","propagTM","scope","wasStable","destroyTM","removeListener","follower","_rmChild","EventEmitter","isPrototypeOf","$global","window","global","RS","___rescope","g","TaskSequencer","objProto","getPrototypeOf","_static","getScope","staticScope","watchs","use","apply","initialState","defaultState","_uid","_onStabilize","_persistenceTm","_cfg","scopeObj","$scope","$stores","$actions","$dispatch","_revs","_require","_sources","_use","match","ref2","_followers","_changesSW","_afterConstructor","applied","initialData","_nextState","shouldApply","managed","nDatas","cDatas","isComplete","follow","changes","_stabilizer","pushTask","nextState","hasDataChange","stable","forcedState","nextData","sync","change","pushState","stabilize","sId","refsCount","persistent","shouldSerialize","dataRefs","stateKeys","stateRefs","inRefsCount","inRefs","number","immediate","restoreRefPath","previous","me","shouldPropag","_destroyTM","removeAllListeners","cStore","origin","targetRevs","targetScope","initialOutputs","_key","defaultName","task","isRunning","curWeight","maxWeight","taskCount","errorCatcher","lastError","disable","handleError","runNow","enable","addEventListener","process","removeEventListener","Date","now","run","weight","Math","max","min","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","currentQueue","queue","draining","queueIndex","cleanUpNextTick","concat","drainQueue","timeout","len","marker","runClearTimeout","Item","noop","nextTick","args","Array","title","browser","env","argv","version","versions","addListener","off","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask"],"mappings":"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","file":"reScope.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 14);\n","module.exports = require(\"is\");","module.exports = require(\"@babel/runtime/helpers/toConsumableArray\");","/*\n *   The MIT License (MIT)\n *   Copyright (c) 2019. Wise Wild Web\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy\n *   of this software and associated documentation files (the \"Software\"), to deal\n *   in the Software without restriction, including without limitation the rights\n *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *   copies of the Software, and to permit persons to whom the Software is\n *   furnished to do so, subject to the following conditions:\n *\n *   The above copyright notice and this permission notice shall be included in all\n *   copies or substantial portions of the Software.\n *\n *   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *   SOFTWARE.\n *\n *   @author : Nathanael Braun\n *   @contact : n8tz.js@gmail.com\n */\n\nconst is = require('is');\n\nexport function walknSet( obj, path, value, stack ) {\n\tif ( is.string(path) )\n\t\tpath = path.split('.');\n\tif ( !path.length )\n\t\treturn false;\n\telse if ( path.length == 1 )\n\t\treturn obj[path[0]] = stack\n\t\t                      ? [...(obj[path[0]] || []), value]\n\t\t                      : value;\n\telse\n\t\treturn walknSet(\n\t\t\tobj[path[0]] =\n\t\t\t\tobj[path[0]] || {},\n\t\t\tpath.slice(1),\n\t\t\tvalue, stack\n\t\t);\n}\n\nexport function walknGet( obj, path, isKey ) {\n\tif ( is.string(path) )\n\t\tpath = path.split('.');\n\treturn path.length\n\t       ? obj[path[0]] && walknGet(obj[path[0]], path.slice(1))\n\t       : obj;\n}\n\n//@todo\nexport function keyWalknSet( obj, path, value, stack ) {\n\tif ( is.string(path) )\n\t\tpath = path.split(/(\\>|\\/)/ig).filter(v => (v !== '>' && v));\n\treturn walknSet(obj, path, value);\n}\n\nexport function keyWalknGet( obj, path, isKey ) {\n\tif ( is.string(path) )\n\t\tpath = path.split(/(\\>|\\/)/ig).filter(v => (v !== '>' && v));\n\treturn path.length\n\t       ? obj[path[0]] && walknGet(obj[path[0]], path.slice(1))\n\t       : obj;\n}","module.exports = require(\"@babel/runtime/helpers/defineProperty\");","module.exports = require(\"@babel/runtime/helpers/assertThisInitialized\");","module.exports = require(\"@babel/runtime/helpers/getPrototypeOf\");","module.exports = require(\"@babel/runtime/helpers/createClass\");","module.exports = require(\"@babel/runtime/helpers/classCallCheck\");","module.exports = require(\"@babel/runtime/helpers/possibleConstructorReturn\");","module.exports = require(\"@babel/runtime/helpers/get\");","module.exports = require(\"@babel/runtime/helpers/inherits\");","module.exports = require(\"shortid\");","/*\n *   The MIT License (MIT)\n *   Copyright (c) 2019. Wise Wild Web\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy\n *   of this software and associated documentation files (the \"Software\"), to deal\n *   in the Software without restriction, including without limitation the rights\n *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *   copies of the Software, and to permit persons to whom the Software is\n *   furnished to do so, subject to the following conditions:\n *\n *   The above copyright notice and this permission notice shall be included in all\n *   copies or substantial portions of the Software.\n *\n *   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *   SOFTWARE.\n *\n *   @author : Nathanael Braun\n *   @contact : n8tz.js@gmail.com\n */\n\nimport is from 'is';\n\nexport default class Emitter {\n\t_events = {};\n\t\n\ton( evt, cb ) {\n\t\tif ( !is.string(evt) && evt )\n\t\t\treturn Object.keys(evt).forEach(k => this.on(k, evt[k]));\n\t\t\n\t\tthis._events[evt] = this._events[evt] || [];\n\t\tthis._events[evt].push(cb);\n\t}\n\t\n\tun( evt, cb ) {\n\t\tif ( !is.string(evt) && evt )\n\t\t\treturn Object.keys(evt).forEach(k => this.un(k, evt[k]));\n\t\t\n\t\tif ( !this._events[evt] ) return;\n\t\tlet i = this._events[evt].indexOf(cb);\n\t\tthis._events[evt].splice(i, 1);\n\t}\n\t\n\temit( evt, ...argz ) {\n\t\tif ( !this._events[evt] ) return;\n\t\tlet lists = [...this._events[evt]];\n\t\t\n\t\tfor ( let i = 0; i < lists.length; i++ )\n\t\t\tlists[i](...argz)\n\t}\n\t\n\taddListener() {\n\t\tthis.on(...arguments);\n\t}\n\t\n\tremoveListener() {\n\t\tthis.un(...arguments);\n\t}\n\t\n\tremoveAllListeners() {\n\t\tthis._events = {};\n\t}\n\t\n\tonce( evt, cb ) {\n\t\tlet fn;\n\t\tthis.on(evt, fn = ( ...argz ) => {\n\t\t\tthis.un(evt, fn);\n\t\t\tcb(...argz)\n\t\t});\n\t}\n\t\n\t\n}","/*\n *\n * Copyright (C) 2019 Nathanael Braun\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport is                                   from \"is\";\nimport shortid                              from \"shortid\";\nimport EventEmitter                         from \"./utils/Emitter\";\nimport {keyWalknGet, keyWalknSet, walknSet} from './utils/utils';\n\nconst __proto__push = ( target, id, parent ) => {\n\t      let fn       = function () {\n\t      };\n\t      fn.prototype = parent ? new parent._[id]() : target[id] || {};\n\t      target[id]   = new fn();\n\t      target._[id] = fn;\n      },\n      allScopes     = {};\n\n\n/**\n * Base Scope object\n */\nclass Scope extends EventEmitter {\n\t\n\tstatic persistenceTm = 1;// if > 0, will wait 'persistenceTm' ms before destroy when dispose reach 0\n\tstatic Store         = null;\n\tstatic scopeRef      = function scopeRef( path ) {\n\t\tthis.path = path;\n\t};\n\tstatic scopes        = allScopes;// all active scopes\n\t/**\n\t * get a parsed reference list from stateMap\n\t * @param _ref\n\t * @returns {{storeId, path, alias: *, ref: *}}\n\t */\n\tstatic stateMapToRefList( sm, state = {}, _refs = [], actions = {}, path = \"\" ) {\n\t\tlet applier;\n\t\tObject.keys(sm).forEach(\n\t\t\tkey => {\n\t\t\t\tlet cpath = path ? path + '.' + key : key;\n\t\t\t\t\n\t\t\t\tsm[key] instanceof Scope.scopeRef\n\t\t\t\t? _refs.push(sm[key].path + ':' + cpath)\n\t\t\t\t: (sm[key] && sm[key] instanceof Function)\n\t\t\t\t  ? key == \"$apply\"\n\t\t\t\t    ? applier = sm[key]\n\t\t\t\t    : actions[key] = sm[key]\n\t\t\t\t  : (sm[key] && sm[key].prototype instanceof Scope.Store)\n\t\t\t\t    ? _refs.push(sm[key].as(cpath))\n\t\t\t\t    : state[cpath] = sm[key]\n\t\t\t\t//: this.stateMapToRefList(sm[key], _refs, path + '.' + key)\n\t\t\t}\n\t\t)\n\t\treturn applier;\n\t}\n\t\n\tstatic getScope( scopes ) {\n\t\tlet skey = is.array(scopes) ? scopes.sort(( a, b ) => {\n\t\t\tif ( a.firstname < b.firstname ) return -1;\n\t\t\tif ( a.firstname > b.firstname ) return 1;\n\t\t\treturn 0;\n\t\t}).join('+') : scopes;\n\t\treturn allScopes[skey] = allScopes[skey] || new Scope({}, { id: skey });\n\t};\n\t\n\t\n\t/**\n\t * Init a ReScope scope\n\t *\n\t * @param storesMap {Object} Object with the initial stores definition / instances\n\t * @param config {Object} Scope config\n\t * {\n\t *     parent {scope} @optional parent scope\n\t *\n\t *     id {string} @optional id ( if this id exist storesMap will be merge on the 'id'\n\t *     scope)\n\t *     key {string} @optional key of the scope ( if no id is set, the scope id will be (parent.id+'>'+key)\n\t *     incrementId {bool} @optional true to add a suffix id, if the provided key or id globally exist\n\t *\n\t *     state {Object} @optional initial state by store alias\n\t *     data {Object} @optional initial data by store alias\n\t *\n\t *     rootEmitter {bool} @optional true to not being destabilized by parent\n\t *     boundedActions {array | regexp} @optional list or regexp of actions not propagated to the parent\n\t *     autoDestroy {true | false | 'inherit'}\n\t *     persistenceTm {number) if > 0, will wait 'persistenceTm' ms before destroy when\n\t *     dispose reach 0 autoDestroy  {bool} will trigger retain & dispose after start\n\t *  }\n\t * @returns {Scope}\n\t */\n\tconstructor( storesMap, { parent, upperScope, key, id, snapshot, state, data, incrementId = !!key, persistenceTm, autoDestroy, rootEmitter, boundedActions } = {} ) {\n\t\tsuper();\n\t\tlet _ = {\n\t\t\tkeyPID: (upperScope && upperScope._id || parent && parent._id || shortid.generate()),\n\t\t\tkey,\n\t\t\tincrementId,\n\t\t\tbaseId: id\n\t\t};\n\t\t\n\t\t\n\t\t// generate / set this scope id\n\t\tid = id || key && (_.keyPID + '>' + key);\n\t\t\n\t\t_.isLocalId = !id;\n\t\t\n\t\tid = id || (\"_____\" + shortid.generate());\n\t\t\n\t\tif ( allScopes[id] && !incrementId ) {// overwrite existing scope\n\t\t\tthis._id = id;\n\t\t\tallScopes[id].register(storesMap);\n\t\t\treturn allScopes[id]\n\t\t}\n\t\telse if ( allScopes[id] && incrementId ) {// generate key id\n\t\t\tlet i = -1;\n\t\t\twhile ( allScopes[id + '[' + (++i) + ']'] ) ;\n\t\t\tid = id + '[' + i + ']';\n\t\t}\n\t\t\n\t\t// register this scope in the static Scope.scopes\n\t\tallScopes[id] = this;\n\t\t\n\t\tthis._id  = id;\n\t\tthis._rev = 0;\n\t\t\n\t\tthis._ = _;\n\t\t\n\t\tthis.actions = {};\n\t\tthis.stores  = {};\n\t\tthis.state   = {};\n\t\tthis.data    = {};\n\t\t\n\t\tthis.parent = parent;\n\t\t\n\t\tif ( autoDestroy == 'inherit' )\n\t\t\tautoDestroy = parent && parent._autoDestroy;\n\t\t\n\t\tthis._autoDestroy = autoDestroy;\n\t\t_.persistenceTm   = persistenceTm || this.constructor.persistenceTm;\n\t\t\n\t\tif ( parent && parent.dead )\n\t\t\tthrow new Error(\"Can't use a dead scope as parent !\");\n\t\t\n\t\t__proto__push(this, 'actions', parent);\n\t\t__proto__push(this, 'stores', parent);\n\t\t__proto__push(this, 'state', parent);\n\t\t__proto__push(this, 'data', parent);\n\t\t\n\t\tthis.sources      = [];\n\t\t_.childScopes     = [];\n\t\t_.childScopesList = [];\n\t\t_.unStableChilds  = 0;\n\t\t_.seenChilds      = 0;\n\t\t_._listening      = {};\n\t\t_._scope          = {};\n\t\t_._mixed          = [];\n\t\t_._mixedList      = [];\n\t\t_.followers       = [];\n\t\t\n\t\tthis.__retains = { all: 0 };\n\t\tthis.__locks   = { all: 1 };\n\t\t\n\t\t// todo\n\t\t_._boundedActions = is.array(boundedActions)\n\t\t                    ? { test: boundedActions.includes.bind(boundedActions) }\n\t\t                    : boundedActions;\n\t\t\n\t\t// register to the parent scope\n\t\tif ( parent ) {\n\t\t\tparent.retain(\"isMyParent\");\n\t\t\tif ( !rootEmitter ) {\n\t\t\t\t!parent._stable && this.wait(\"waitingParent\");\n\t\t\t\tparent.on(_._parentList = {\n\t\t\t\t\t'stable'  : s => this.release(\"waitingParent\"),\n\t\t\t\t\t'unstable': s => this.wait(\"waitingParent\"),\n\t\t\t\t\t'update'  : s => this._propag()\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparent.on(_._parentList = {\n\t\t\t\t\t'update': s => this._propag()\n\t\t\t\t});\n\t\t\t}\n\t\t\t// this.register(parent.__scope, state, data);\n\t\t}\n\t\t\n\t\t// register this scope stores\n\t\tthis.register(storesMap, state, data);\n\t\tthis.__locks.all--;\n\t\tthis._stable = !this.__locks.all;\n\t\t\n\t\tif ( parent ) {\n\t\t\tparent._addChild(this);\n\t\t}\n\t\t\n\t\t\n\t\t// restore snapshots\n\t\tthis.restore(snapshot);\n\t\t\n\t\t\n\t\tif ( autoDestroy )\n\t\t\tsetTimeout(\n\t\t\t\ttm => {\n\t\t\t\t\tthis.retain(\"autoDestroy\");\n\t\t\t\t\tthis.dispose(\"autoDestroy\");\n\t\t\t\t}\n\t\t\t)\n\t\t\n\t}\n\t\n\t/**\n\t *\n\t * Mount the stores in storesList, in this scope or in its parents or mixed scopes\n\t *\n\t * @param storeIdList {string|storeRef} Store name, Array of Store names, or Rescope\n\t *     store ref from Store::as or Store:as\n\t * @param state\n\t * @param data\n\t * @returns {Scope}\n\t */\n\tmount( storeIdList, snapshot, state, data ) {\n\t\tif ( is.array(storeIdList) ) {\n\t\t\tstoreIdList.forEach(storeId => this._mount(storeId, snapshot, state, data));\n\t\t}\n\t\telse {\n\t\t\tthis._mount(...arguments);\n\t\t}\n\t\treturn this;\n\t}\n\t\n\t_mount( id, snapshot, state, data ) {\n\t\tlet ref, _ = this._;\n\t\t\n\t\tref = this.parseRef(id)\n\t\t\n\t\tif ( id == \"$parent\" ) return;\n\t\tif ( !_._scope[ref.storeId] ) {//ask mixed || parent\n\t\t\tif ( _._mixed.reduceRight(( mounted, ctx ) => (mounted || ctx._mount(id, snapshot, state, data)), false) ||\n\t\t\t\t!this.parent )\n\t\t\t\treturn;\n\t\t\treturn this.parent._mount(...arguments);\n\t\t}\n\t\telse {\n\t\t\tlet store = _._scope[ref.storeId], taskQueue = [];\n\t\t\tif ( Scope.isStoreClass(store) ) {\n\t\t\t\t_._scope[ref.storeId] = new store(this, {\n\t\t\t\t\t//snapshot,\n\t\t\t\t\tname: ref.storeId,\n\t\t\t\t\tstate,\n\t\t\t\t\tdata\n\t\t\t\t}, taskQueue);\n\t\t\t\twhile ( taskQueue.length ) taskQueue.shift()();\n\t\t\t}\n\t\t\telse if ( Scope.isScopeClass(store) ) {\n\t\t\t\tstore = _._scope[ref.storeId] = new store({ $parent: this }, {\n\t\t\t\t\tkey        : ref.storeId,\n\t\t\t\t\tincrementId: true,\n\t\t\t\t\tupperScope : this\n\t\t\t\t\t//autoDestroy: true\n\t\t\t\t\t//parent: this\n\t\t\t\t});\n\t\t\t\t//_._scope[ ref.storeId ].retain(\"scopedChildScope\");\n\t\t\t\t//_watchStore(ref.storeId);\n\t\t\t\tif ( ref.path.length > 1 )\n\t\t\t\t\t_._scope[ref.storeId].mount(ref.path.slice(1).join('.'), snapshot, state, data)\n\t\t\t\t//else return _._scope[ ref.storeId ];\n\t\t\t}\n\t\t\tif ( Scope.isStore(store) ) {\n\t\t\t\tif ( state !== undefined && data === undefined )\n\t\t\t\t\tstore.setState(state);\n\t\t\t\telse if ( state !== undefined )\n\t\t\t\t\tstore.state = state;\n\t\t\t\t\n\t\t\t\tif ( data !== undefined )\n\t\t\t\t\tstore.push(data);\n\t\t\t}\n\t\t\tif ( Scope.isScope(store) ) {\n\t\t\t\tif ( state !== undefined )\n\t\t\t\t\tstore.setState(state);\n\t\t\t\tif ( ref.path.length > 1 )\n\t\t\t\t\tstore._mount(ref.path.slice(1).join('.'))\n\t\t\t}\n\t\t\tthis._watchStore(ref.storeId);\n\t\t}\n\t\t\n\t\t\n\t\treturn _._scope[ref.storeId];\n\t}\n\t\n\t/**\n\t * Register stores in storesMap & link them in the protos\n\t * @param storesMap\n\t * @param state\n\t * @param data\n\t */\n\tregister( storesMap, state = {}, data = {} ) {\n\t\tthis.relink(storesMap, this, false, false);\n\t\tObject.keys(storesMap).forEach(\n\t\t\tid => {\n\t\t\t\tif ( id == \"$parent\" ) return;\n\t\t\t\tif ( storesMap[id].singleton || (is.fn(storesMap[id]) && (state[id] || data[id])) ) {\n\t\t\t\t\tthis._mount(id, undefined, state[id], data[id])\n\t\t\t\t}\n\t\t\t\telse if ( state[id] || data[id] ) {\n\t\t\t\t\tif ( data[id] ) {\n\t\t\t\t\t\tif ( state[id] )\n\t\t\t\t\t\t\tthis.stores[id].state = state[id];\n\t\t\t\t\t\tthis.stores[id].push(data[id]);\n\t\t\t\t\t}\n\t\t\t\t\telse if ( state[id] ) {\n\t\t\t\t\t\tthis.stores[id].setState(state[id]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis._watchStore(id);\n\t\t\t\t}\n\t\t\t}\n\t\t)\n\t\t\n\t}\n\t\n\t/**\n\t * Map srcCtx store's on targetCtx headers proto's\n\t * @param srcCtx\n\t * @param targetCtx\n\t * @param state\n\t * @param data\n\t */\n\trelink( srcCtx, targetCtx = this, external, force ) {\n\t\tlet _ = this._;\n\t\tObject.keys(srcCtx)\n\t\t      .forEach(\n\t\t\t      id => {\n\t\t\t\t      let hotReloading, actions, activeActions;\n\t\t\t\t\n\t\t\t\t      // same store def : ignore\n\t\t\t\t      if ( !force && targetCtx._._scope[id] === srcCtx[id] ||\n\t\t\t\t\t      targetCtx._._scope[id] && (targetCtx._._scope[id].constructor === srcCtx[id]) )\n\t\t\t\t\t      return;\n\t\t\t\t\n\t\t\t\t      // hot switch\n\t\t\t\t      if ( !force && targetCtx._._scope[id] ) {\n\t\t\t\t\t\n\t\t\t\t\t      if ( !external && !is.fn(targetCtx._._scope[id]) ) {// mounted store\n\t\t\t\t\t\t      //console.info(\"Rescope Store : \", id, \" already exist in this scope ! ( Hot switching the store ) !!!\");\n\t\t\t\t\t\t      targetCtx._._scope[id].__proto__ = srcCtx[id].prototype;\n\t\t\t\t\t\t      targetCtx._._scope[id]._storeHasBeenHotSwitched\n\t\t\t\t\t\t      && targetCtx._._scope[id]._storeHasBeenHotSwitched(srcCtx[id]);\n\t\t\t\t\t      }\n\t\t\t\t\t      else if ( !external && is.fn(targetCtx._._scope[id]) )\n\t\t\t\t\t\t      targetCtx._._scope[id] = srcCtx[id];\n\t\t\t\t\t\n\t\t\t\t      }\n\t\t\t\t      else if ( !force && !external )\n\t\t\t\t\t      _._scope[id] = srcCtx[id];\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t      // map the store id\n\t\t\t\t      Object.defineProperty(\n\t\t\t\t\t      targetCtx._.stores.prototype,\n\t\t\t\t\t      id,\n\t\t\t\t\t      {\n\t\t\t\t\t\t      enumerable  : true,\n\t\t\t\t\t\t      configurable: true,\n\t\t\t\t\t\t      get         : () => _._scope[id]\n\t\t\t\t\t      }\n\t\t\t\t      );\n\t\t\t\t\n\t\t\t\t      activeActions = targetCtx._.actions.prototype;\n\t\t\t\t      // not mapping hierarchic scopes\n\t\t\t\t      if ( id !== \"$parent\" ) {\n\t\t\t\t\t      // map state & data\n\t\t\t\t\t      Object.defineProperty(\n\t\t\t\t\t\t      targetCtx._.state.prototype,\n\t\t\t\t\t\t      id,\n\t\t\t\t\t\t      {\n\t\t\t\t\t\t\t      enumerable  : true,\n\t\t\t\t\t\t\t      configurable: true,\n\t\t\t\t\t\t\t      get         : () => (_._scope[id] && _._scope[id].state),\n\t\t\t\t\t\t\t      set         : ( v ) => (this._mount(id, undefined, v))\n\t\t\t\t\t\t      }\n\t\t\t\t\t      );\n\t\t\t\t\t      Object.defineProperty(\n\t\t\t\t\t\t      targetCtx._.data.prototype,\n\t\t\t\t\t\t      id,\n\t\t\t\t\t\t      {\n\t\t\t\t\t\t\t      enumerable  : true,\n\t\t\t\t\t\t\t      configurable: true,\n\t\t\t\t\t\t\t      get         : () => (_._scope[id] && _._scope[id].data),\n\t\t\t\t\t\t\t      set         : ( v ) => (this._mount(id, undefined, undefined, v))\n\t\t\t\t\t\t      }\n\t\t\t\t\t      );\n\t\t\t\t\t      // action mapping\n\t\t\t\t\t      actions = srcCtx[id] instanceof Scope.Store\n\t\t\t\t\t                ? srcCtx[id].constructor.actions\n\t\t\t\t\t                : srcCtx[id].actions;\n\t\t\t\t\t\n\t\t\t\t\t      if ( Scope.isScopeClass(_._scope[id]) )\n\t\t\t\t\t\t      this._mount(id);\n\t\t\t\t\t\n\t\t\t\t\t      if ( Scope.isScope(_._scope[id]) ) {// map hierarchic scopes\n\t\t\t\t\t\t      activeActions[id] = _._scope[id].actions;\n\t\t\t\t\t      }\n\t\t\t\t\t      else if ( !Scope.isStore(_._scope[id]) && !Scope.isStoreClass(_._scope[id]) )\n\t\t\t\t\t\t      return;\n\t\t\t\t\t\n\t\t\t\t\t      actions &&\n\t\t\t\t\t      Object.keys(actions)\n\t\t\t\t\t            .forEach(\n\t\t\t\t\t\t            ( act ) => {\n\t\t\t\t\t\t\t            if ( activeActions.hasOwnProperty(act) )\n\t\t\t\t\t\t\t\t            activeActions[act].__targetStores++;\n\t\t\t\t\t\t\t            else {\n\t\t\t\t\t\t\t\t            activeActions[act]                = this.dispatch.bind(this, act);\n\t\t\t\t\t\t\t\t            activeActions[act].__targetStores = 1;\n\t\t\t\t\t\t\t            }\n\t\t\t\t\t\t            }\n\t\t\t\t\t            );\n\t\t\t\t      }\n\t\t\t\t      else {\n\t\t\t\t\t      activeActions[id] = srcCtx[id].actions;\n\t\t\t\t      }\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t      // remount the store if it was hot reloaded\n\t\t\t\t      if ( hotReloading )\n\t\t\t\t\t      this._mount(id, null, hotReloading);\n\t\t\t      }\n\t\t      )\n\t}\n\t\n\t/**\n\t * Make this scope watching the local store 'id'\n\t * @param id\n\t * @returns {boolean}\n\t * @private\n\t */\n\t_watchStore( id ) {\n\t\tlet _ = this._;\n\t\tif ( !_._listening[id] && !is.fn(_._scope[id]) ) {\n\t\t\t!_._scope[id]._autoDestroy && _._scope[id].retain(\"scoped\");\n\t\t\t!_._scope[id].isStable() && this.wait(id);\n\t\t\t_._scope[id].on(\n\t\t\t\t_._listening[id] = {\n\t\t\t\t\t'destroy' : s => {\n\t\t\t\t\t\tdelete _._listening[id];\n\t\t\t\t\t\t_._scope[id] = _._scope[id].constructor;\n\t\t\t\t\t},\n\t\t\t\t\t'update'  : s => this.propag(),\n\t\t\t\t\t'stable'  : s => this.release(id),\n\t\t\t\t\t'unstable': s => this.wait(id)\n\t\t\t\t});\n\t\t}\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Mix targetCtx on this scope\n\t * Mixed scope parents are NOT mapped\n\t * @param targetCtx\n\t */\n\tmixin( targetCtx ) {\n\t\tlet parent = this.parent,\n\t\t    lists,\n\t\t    _      = this._;\n\t\t\n\t\t_._mixed.push(targetCtx);\n\t\t\n\t\ttargetCtx.retain(\"mixedTo\");\n\t\t\n\t\tif ( !targetCtx._stable )\n\t\t\tthis.wait(targetCtx._id);\n\t\t\n\t\t_._mixedList.push(lists = {\n\t\t\t'stable'  : s => this.release(targetCtx._id),\n\t\t\t'unstable': s => this.wait(targetCtx._id),\n\t\t\t'update'  : s => this._propag()\n\t\t});\n\t\t\n\t\ttargetCtx.on(lists);\n\t\t\n\t\t// reset protos\n\t\t// push new proto with parent\n\t\t__proto__push(this, 'actions', parent);\n\t\t__proto__push(this, 'stores', parent);\n\t\t__proto__push(this, 'state', parent);\n\t\t__proto__push(this, 'data', parent);\n\t\t\n\t\t// bind local accessors in the new proto\n\t\tthis.relink(_._scope, this, false, true);\n\t\t\n\t\t_._mixed.forEach(\n\t\t\tctx => {\n\t\t\t\t// push protos\n\t\t\t\t__proto__push(this, 'actions');\n\t\t\t\t__proto__push(this, 'stores');\n\t\t\t\t__proto__push(this, 'state');\n\t\t\t\t__proto__push(this, 'data');\n\t\t\t\tthis.stores.__origin = \"mixed \" + ctx._id;\n\t\t\t\t// write mixed accessors\n\t\t\t\tctx.relink(ctx._._scope, this, true, true)\n\t\t\t}\n\t\t)\n\t}\n\t\n\t/**\n\t * Bind stores from this scope, his parents or mixed scopes to obj\n\t *\n\t * @param target {React.Component|Store|function}\n\t * @param key {string} stores keys to bind updates\n\t * @param as\n\t * @param setInitial {boolean} false to not propag initial value (default : true)\n\t */\n\tbind( target, key, as, setInitial = true, revMap = {} ) {\n\t\tlet lastRevs, data, refKeys;\n\t\tif ( key && !is.array(key) )\n\t\t\tkey = [key];\n\t\t\n\t\tif ( as === false || as === true ) {\n\t\t\tsetInitial = as;\n\t\t\tas         = null;\n\t\t}\n\t\t\n\t\trefKeys = key\n\t\t\t.map(id => (is.string(id) ? id : id.name))\n\t\t\t.map(id => (this.parseRef(id)));\n\t\t\n\t\t\n\t\tthis._.followers.push(\n\t\t\t[\n\t\t\t\ttarget,\n\t\t\t\tkey,\n\t\t\t\tas || undefined,\n\t\t\t\tlastRevs = refKeys.reduce(( revs, ref ) => {\n\t\t\t\t\trevs[ref.storeId] = revs[ref.storeId] || {\n\t\t\t\t\t\trev : 0,\n\t\t\t\t\t\trefs: []\n\t\t\t\t\t};\n\t\t\t\t\trevs[ref.storeId].refs.push(ref);\n\t\t\t\t\treturn revs;\n\t\t\t\t}, revMap)\n\t\t\t]);\n\t\t\n\t\tthis.mount(key);\n\t\tthis.retainStores(Object.keys(lastRevs), 'listeners');\n\t\t\n\t\tif ( setInitial && this._stable ) {\n\t\t\tdata = this.getUpdates(lastRevs);\n\t\t\tif ( !data ) return this;\n\t\t\tif ( typeof target != \"function\" ) {\n\t\t\t\tif ( as ) target.setState({ [as]: data });\n\t\t\t\telse target.setState(data);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttarget(data);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Un bind this scope off the given component-keys\n\t * @param target\n\t * @param key\n\t * @returns {Array.<*>}\n\t */\n\tunBind( target, key, as ) {\n\t\tlet followers = this._.followers,\n\t\t    i         = followers && followers.length;\n\t\twhile ( followers && i-- )\n\t\t\tif ( followers[i][0] === target &&\n\t\t\t\t('' + followers[i][1]) == ('' + key) &&\n\t\t\t\tfollowers[i][2] == as ) {\n\t\t\t\tthis.disposeStores(Object.keys(followers[i][3]), 'listeners');\n\t\t\t\treturn followers.splice(i, 1);\n\t\t\t}\n\t}\n\t\n\t/**\n\t * Mount the stores in storeIdList from this scope, its parents and mixed scope\n\t * Bind them to 'to'\n\t * Hook 'to' so it will auto unbind on 'destroy' or 'componentWillUnmount'\n\t * @param target\n\t * @param storeIdList\n\t * @param bind\n\t * @returns {Object} Initial outputs of the stores in 'storesList'\n\t */\n\tmap( target, storeIdList, bind = true, revMap ) {\n\t\tlet Store   = this.constructor.Store;\n\t\tstoreIdList = is.array(storeIdList) ? storeIdList : [storeIdList];\n\t\tlet refList = storeIdList.map(this.parseRef);\n\t\tthis.mount(storeIdList);\n\t\tif ( bind && target instanceof Store ) {\n\t\t\tStore.map(target, storeIdList, this, this, false)\n\t\t}\n\t\telse if ( bind ) {\n\t\t\tthis.bind(target, storeIdList, undefined, false);\n\t\t\t\n\t\t\tlet mixedCWUnmount,\n\t\t\t    unMountKey = target.isReactComponent ? \"componentWillUnmount\" : \"destroy\";\n\t\t\t\n\t\t\tif ( target.hasOwnProperty(unMountKey) ) {\n\t\t\t\tmixedCWUnmount = target[unMountKey];\n\t\t\t}\n\t\t\t\n\t\t\ttarget[unMountKey] = ( ...argz ) => {\n\t\t\t\tdelete target[unMountKey];\n\t\t\t\tif ( mixedCWUnmount )\n\t\t\t\t\ttarget[unMountKey] = mixedCWUnmount;\n\t\t\t\t\n\t\t\t\tthis.unBind(target, storeIdList);\n\t\t\t\treturn target[unMountKey] && target[unMountKey](...argz);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn revMap && this.getUpdates(revMap)\n\t\t\t|| refList.reduce(( data, ref ) => {\n\t\t\t\twalknSet(data, ref.alias || ref.path, this.retrieve(ref.path))\n\t\t\t\treturn data;\n\t\t\t}, {});\n\t}\n\t\n\t/**\n\t * Get current data value from json path\n\t * @param path\n\t * @returns {string|*}\n\t */\n\tretrieve( path = \"\" ) {\n\t\tpath = is.string(path) ? path.split('.') : path;\n\t\t\n\t\t\n\t\treturn path &&\n\t\t\tthis.stores[path[0]] &&\n\t\t\tthis.stores[path[0]].retrieve &&\n\t\t\tthis.stores[path[0]].retrieve(path.slice(1));\n\t}\n\t\n\t/**\n\t * Restore all nodes in a jsonPath\n\t * @param path\n\t * @returns {string|*}\n\t */\n\trestoreRefPath( path = \"\" ) {\n\t\tpath = is.string(path) ? path.split('.') : path;\n\t\t\n\t\tlet obj, i = 0, cScope = this;\n\t\t\n\t\twhile ( i < path.length ) {\n\t\t\tobj = cScope.stores[path[i]];\n\t\t\tif ( Scope.isScopeClass(obj)\n\t\t\t\t||\n\t\t\t\tScope.isStoreClass(obj) ) {\n\t\t\t\tcScope.mount(path[0]);\n\t\t\t\tobj = cScope.stores[path[i]];\n\t\t\t}\n\t\t\t\n\t\t\tif ( Scope.isScope(obj) ) {\n\t\t\t\tcScope = obj;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if ( Scope.isStore(obj) ) {\n\t\t\t\tobj.restore();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\t/**\n\t * Get target store from json path\n\t * @param path\n\t * @returns {string|*}\n\t */\n\tretrieveStore( path = \"\" ) {\n\t\tpath = is.string(path) ? path.split('.') : path;\n\t\treturn path\n\t\t\t&& path.length\n\t\t\t&& (\n\t\t\t\tpath.length != 1 && this.stores[path[0]].retrieveStore\n\t\t\t\t? this.stores[path[0]].retrieveStore(path.slice(1))\n\t\t\t\t: path.length == 1 && this.stores[path[0]]\n\t\t\t);\n\t}\n\t\n\t/**\n\t * Get or update stores revisions in 'storesRevMap'\n\t * @param storesRevMap\n\t * @param local\n\t * @returns {{}}\n\t */\n\tgetStoresRevs( storesRevMap = {}, local ) {\n\t\tlet ctx = this._._scope;\n\t\tif ( !storesRevMap ) {\n\t\t\tstoresRevMap = {};\n\t\t}\n\t\tObject.keys(ctx).forEach(\n\t\t\tid => {\n\t\t\t\tif ( id == \"$parent\" ) return;\n\t\t\t\tif ( !is.fn(ctx[id])\n\t\t\t\t) {\n\t\t\t\t\tstoresRevMap[id] = ctx[id]._rev;\n\t\t\t\t}\n\t\t\t\telse if ( !storesRevMap.hasOwnProperty(id) )\n\t\t\t\t\tstoresRevMap[id] = false\n\t\t\t}\n\t\t);\n\t\tif ( !local ) {\n\t\t\tthis._._mixed.reduce(( updated, ctx ) => (ctx.getStoresRevs(storesRevMap), storesRevMap), storesRevMap);\n\t\t\tthis.parent && this.parent.getStoresRevs(storesRevMap);\n\t\t}\n\t\treturn storesRevMap;\n\t}\n\t\n\t/**\n\t * Recursively get all stores revs\n\t * @param childs\n\t * @returns {Array}\n\t * @private\n\t */\n\t_getRevMap( storesRevMap = {} ) {\n\t\tlet ctx = this._._scope;\n\t\tObject.keys(ctx).forEach(\n\t\t\tid => {\n\t\t\t\tif ( id == \"$parent\" || storesRevMap[id] ) return;\n\t\t\t\tstoresRevMap[id] = { rev: ctx[id]._rev, refs: [] };\n\t\t\t\t\n\t\t\t});\n\t\tthis._._mixed.reduceRight(\n\t\t\t( storesRevMap, ctx ) => (ctx._getRevMap(storesRevMap)), storesRevMap);\n\t\tthis.parent && this.parent._getRevMap(storesRevMap);\n\t\treturn storesRevMap;\n\t}\n\t\n\t/**\n\t * Get updated output basing storesRevMap's revisions.\n\t * If a store in 'storesRevMap' was updated; add it to 'output' & update storesRevMap\n\t * @param storesRevMap\n\t * @param output\n\t * @param updated\n\t * @returns {*|{}}\n\t */\n\tgetRefsUpdates( refs, revMap, output ) {\n\t\trevMap = revMap || refs\n\t\t\t.map(id => (is.string(id) ? id : id.name))\n\t\t\t.map(id => (this.parseRef(id)))\n\t\t\t.reduce(( revs, ref ) => {\n\t\t\t\trevs[ref.storeId] = revs[ref.storeId] || {\n\t\t\t\t\trev : 0,\n\t\t\t\t\trefs: []\n\t\t\t\t};\n\t\t\t\trevs[ref.storeId].refs.push(ref);\n\t\t\t\treturn revs;\n\t\t\t}, {});\n\t\t\n\t\treturn this.getUpdates(revMap, output)\n\t}\n\t\n\t/**\n\t * Get or update output basing storesRevMap's revisions.\n\t * If a store in 'storesRevMap' was updated; add it to 'output' & update storesRevMap\n\t * @param storesRevMap\n\t * @param output\n\t * @param updated\n\t * @returns {*|{}}\n\t */\n\tgetUpdates( storesRevMap, output, updated ) {\n\t\toutput       = output || {};\n\t\tstoresRevMap = storesRevMap || this._getRevMap();\n\t\tObject.keys(storesRevMap).forEach(\n\t\t\tid => {\n\t\t\t\tlet store        = this.stores[id];\n\t\t\t\tstoresRevMap[id] = storesRevMap[id] || { rev: 0, refs: [] };\n\t\t\t\t\n\t\t\t\tif ( store && is.fn(store) ) {\n\t\t\t\t\tupdated    = true;\n\t\t\t\t\toutput[id] = undefined;\n\t\t\t\t}\n\t\t\t\telse if ( store && store._rev > storesRevMap[id].rev ) {\n\t\t\t\t\tstoresRevMap[id].rev = store._rev;\n\t\t\t\t\tupdated              = true;\n\t\t\t\t\tstoresRevMap[id].refs.forEach(\n\t\t\t\t\t\tref => {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\toutput[ref.alias] = this.retrieve(ref.path)\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t)\n\t\treturn updated && output;\n\t}\n\t\n\t/**\n\t * Recursively get all child scopes\n\t * @param childs\n\t * @returns {Array}\n\t * @private\n\t */\n\t_getAllChilds( childs = [] ) {\n\t\tchilds.push(...this._.childScopes);\n\t\tthis._.childScopes.forEach(\n\t\t\tctx => {\n\t\t\t\tctx._getAllChilds(childs);\n\t\t\t}\n\t\t);\n\t\treturn childs;\n\t}\n\t\n\t/**\n\t * Serialize all active stores state & data in every childs & mixed scopes\n\t *\n\t * Scopes without key or id are ignored\n\t * @param output\n\t * @returns {{}}\n\t */\n\tserialize( cfg = {}, output = {} ) {\n\t\tlet ctx                                  = this._._scope,\n\t\t    { baseId, key, keyPID, incrementId } = this._,\n\t\t    {\n\t\t\t    alias,\n\t\t\t    parentAlias,\n\t\t    }                                    = cfg,\n\t\t    sid                                  = key\n\t\t                                           ? (parentAlias || keyPID) + '>' + key\n\t\t                                           : alias || parentAlias && (parentAlias + '/' + baseId) || this._id;\n\t\t\n\t\t\n\t\t//alias = alias || baseId;\n\t\treturn this.serialize_ex(cfg, output, sid, alias, [\"$parent\"])\n\t}\n\t\n\tserialize_ex( cfg = {}, output = {}, sid, alias, exclude ) {\n\t\tlet _               = this._,\n\t\t    ctx             = _._scope,\n\t\t    { incrementId } = _,\n\t\t    {\n\t\t\t    withChilds = true,\n\t\t\t    withMixed  = true,\n\t\t\t    norefs,\n\t\t    }               = cfg;\n\t\t\n\t\tif ( keyWalknGet(output, sid) ) {\n\t\t\tif ( !incrementId )// done\n\t\t\t\treturn output;\n\t\t\telse if ( incrementId ) {// generate key id\n\t\t\t\tlet i = -1;\n\t\t\t\twhile ( keyWalknGet(output, sid + '[' + (++i) + ']') ) ;\n\t\t\t\tsid = sid + '[' + i + ']';\n\t\t\t}\n\t\t}\n\t\t\n\t\tkeyWalknSet(output, sid, {});\n\t\t\n\t\tObject.keys(ctx).forEach(\n\t\t\tid => {\n\t\t\t\tif ( exclude.includes(id) || Scope.isStoreClass(ctx[id]) || Scope.isScopeClass(ctx[id]) )\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tctx[id].serialize({ ...cfg, parentAlias: sid }, output);\n\t\t\t}\n\t\t)\n\t\t\n\t\twithChilds && _.childScopes.forEach(\n\t\t\tctx => {\n\t\t\t\t!ctx._.isLocalId && ctx.serialize({\n\t\t\t\t\t                                  withChild  : true,\n\t\t\t\t\t                                  withParents: false,\n\t\t\t\t\t                                  parentAlias: sid,\n\t\t\t\t\t                                  withMixed,\n\t\t\t\t\t                                  norefs,\n\t\t\t\t                                  }, output);\n\t\t\t}\n\t\t);\n\t\t\n\t\twithMixed && _._mixed.forEach(\n\t\t\tctx => {\n\t\t\t\t!ctx._.isLocalId && ctx.serialize({\n\t\t\t\t\t                                  withChild  : false,\n\t\t\t\t\t                                  withParents: false,\n\t\t\t\t\t                                  withMixed,\n\t\t\t\t\t                                  norefs\n\t\t\t\t                                  }, output);\n\t\t\t}\n\t\t);\n\t\t\n\t\tif ( alias ) {\n\t\t\toutput = Object.keys(output)\n\t\t\t               .reduce(\n\t\t\t\t               ( h, k ) => (\n\t\t\t\t\t               h[k === this._id\n\t\t\t\t\t                 ? alias\n\t\t\t\t\t                 : k] = output[k],\n\t\t\t\t\t\t               h\n\t\t\t\t               ),\n\t\t\t\t               {}\n\t\t\t               )\n\t\t}\n\t\treturn output;\n\t}\n\t\n\t/**\n\t * Restore state & data from the serialize fn\n\t * @param snapshot\n\t * @param force\n\t */\n\trestore( snapshot, cfg = {}, force = is.bool(cfg) && cfg ) {\n\t\tlet ctx = this._._scope, snap;\n\t\t\n\t\tif ( snapshot && cfg && cfg.alias && cfg.alias != this._id ) {\n\t\t\tsnap = {\n\t\t\t\t...snapshot,\n\t\t\t\t[this._id]: snapshot[cfg.alias]\n\t\t\t}\n\t\t\tdelete snap[cfg.alias];\n\t\t\tsnapshot = snap;\n\t\t}\n\t\tsnapshot = snapshot\n\t\t\t&& keyWalknGet(snapshot, this._id)\n\t\t\t|| this.takeSnapshotByKey(this._id);\n\t\t\n\t\t\n\t\tif ( !snapshot )\n\t\t\treturn;\n\t\t\n\t\tthis._.snapshot = { ...snapshot };\n\t\t\n\t\tsnap          = snapshot['/'];\n\t\tsnapshot['/'] = { ...snap };\n\t\tsnap && Object.keys(snap).forEach(\n\t\t\tname => {\n\t\t\t\tif ( name == \"$parent\" ) return;\n\t\t\t\t\n\t\t\t\tif ( ctx[name] ) {\n\t\t\t\t\t\n\t\t\t\t\tif ( force && !is.fn(ctx[name]) )\n\t\t\t\t\t\tctx[name].destroy();\n\t\t\t\t\t\n\t\t\t\t\tthis._mount(name);// quiet\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t)\n\t\t\n\t\tthis._._mixed.forEach(\n\t\t\tctx => {\n\t\t\t\t!ctx._.isLocalId && ctx.restore(undefined, force);\n\t\t\t}\n\t\t);\n\t\t\n\t\tthis._.childScopes.forEach(\n\t\t\tctx => {\n\t\t\t\t!ctx._.isLocalId && ctx.restore(undefined, force);\n\t\t\t}\n\t\t);\n\t}\n\t\n\tgetSnapshotByKey( key, local ) {\n\t\t// only have the local snap\n\t\tif ( this._.snapshot && key.startsWith(this._id) ) {\n\t\t\tlet obj = keyWalknGet(this._.snapshot, key.substr(this._id.length))\n\t\t\treturn obj;\n\t\t}\n\t\telse return !local\n\t\t\t&& this.parent\n\t\t\t&& this.parent.getSnapshotByKey(key)\n\t\t\t||\n\t\t\tthis.stores.$parent\n\t\t\t&& this.stores.$parent.getSnapshotByKey(key);\n\t\t\n\t}\n\t\n\tgetSnapshotByKeyExt( snapshot, key, local ) {\n\t\t// only have the local snap\n\t\tif ( snapshot ) {\n\t\t\tlet obj = keyWalknGet(snapshot, key)\n\t\t\treturn obj;\n\t\t}\n\t\t\n\t}\n\t\n\ttakeSnapshotByKey( key, local ) {\n\t\tif ( this._.snapshot && key.startsWith(this._id) ) {\n\t\t\tlet obj = keyWalknGet(this._.snapshot, key.substr(this._id.length))\n\t\t\tif ( obj ) {\n\t\t\t\tthis.deleteSnapshotByKey(key, true);\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\t\telse return !local\n\t\t\t&& this.parent\n\t\t\t&& this.parent.takeSnapshotByKey(key)\n\t\t\t||\n\t\t\tthis.stores.$parent\n\t\t\t&& this.stores.$parent.takeSnapshotByKey(key);\n\t}\n\t\n\tdeleteSnapshotByKey( key, local ) {\n\t\tif ( this._.snapshot && key.startsWith(this._id) ) {\n\t\t\tlet obj = keyWalknGet(this._.snapshot, key.substr(this._id.length).replace(/^(.*[\\>|\\/])[^\\>|\\/]+$/ig, '$1'))\n\t\t\tif ( obj )\n\t\t\t\tdelete obj[key.replace(/^.*[\\>|\\/]([^\\>|\\/]+)$/ig, '$1')]\n\t\t}\n\t\treturn !local\n\t\t\t&& this.parent\n\t\t\t&& this.parent.deleteSnapshotByKey(key)\n\t\t\t||\n\t\t\tthis.stores.$parent\n\t\t\t&& this.stores.$parent.deleteSnapshotByKey(key);\n\t}\n\t\n\tsetState( pState ) {\n\t\tObject.keys(pState)\n\t\t      .forEach(k => (this.state[k] = pState[k]))\n\t}\n\t\n\t/**\n\t * get a parsed reference\n\t * @param _ref\n\t * @returns {{storeId, path, alias: *, ref: *}}\n\t */\n\tparseRef( _ref ) {\n\t\tif ( typeof _ref !== 'string' ) {// @todo : rm this\n\t\t\tthis.register({ [_ref.name]: _ref.store });\n\t\t\t_ref = _ref.name;\n\t\t}\n\t\tlet ref = _ref.split(':');\n\t\tref[0]  = ref[0].split('.');\n\t\treturn {\n\t\t\tstoreId: ref[0][0],\n\t\t\tpath   : ref[0],\n\t\t\talias  : ref[1] || ref[0][ref[0].length - 1],\n\t\t\tref    : _ref\n\t\t};\n\t}\n\t\n\t/**\n\t * Dispatch an action to the top parent & mixed scopes, in all stores\n\t *\n\t * @param action\n\t * @param data\n\t * @returns {Scope}\n\t */\n\tdispatch( action, ...argz ) {\n\t\tif ( this.dead ) {\n\t\t\tconsole.warn(\"Dispatch was called on a dead scope, check you're async functions in this stack...\", (new Error()).stack);\n\t\t\treturn;\n\t\t}\n\t\tlet bActs = this._._boundedActions;\n\t\tObject.keys(this._._scope)\n\t\t      .forEach(\n\t\t\t      id => {\n\t\t\t\t      if ( id == \"$parent\" ) return;\n\t\t\t\t      if ( !is.fn(this._._scope[id]) )\n\t\t\t\t\t      this._._scope[id].trigger(action, ...argz);\n\t\t\t      }\n\t\t      );\n\t\t\n\t\tif ( bActs && bActs.test(action) )\n\t\t\treturn this;\n\t\t\n\t\tthis._._mixed.forEach(( ctx ) => (ctx.dispatch(action, ...argz)));\n\t\tthis.parent && this.parent.dispatch(action, ...argz);\n\t\treturn this;\n\t}\n\t\n\ttrigger() {\n\t\tthis.dispatch(...arguments);\n\t}\n\t\n\t/**\n\t * once('stable', cb)\n\t * @param obj {React.Component|Store|function)\n\t * @param key {string} optional key where to map the public state\n\t */\n\tthen( cb ) {\n\t\tif ( !this._stable )\n\t\t\treturn this.once('stable', e => this.then(cb));\n\t\t\n\t\treturn cb(this.data);\n\t}\n\t\n\tonceStableTree( cb ) {\n\t\tif ( this._.unStableChilds )\n\t\t\treturn this.once('stableTree', e => this.onceStableTree(cb));\n\t\treturn cb(this.data);\n\t}\n\t\n\t/**\n\t * Call retain on the scoped stores basing the given list\n\t *\n\t * @param stores\n\t * @param reason\n\t */\n\tretainStores( stores = [], reason ) {\n\t\tstores.forEach(\n\t\t\tid => (this.stores[id] && this.stores[id].retain && this.stores[id].retain(reason))\n\t\t)\n\t}\n\t\n\t/**\n\t * Call retain on the scoped stores\n\t *\n\t * @param stores\n\t * @param reason\n\t */\n\tdisposeStores( stores = [], reason ) {\n\t\tstores.forEach(\n\t\t\tid => (this.stores[id] && this.stores[id].dispose && this.stores[id].dispose(reason))\n\t\t)\n\t}\n\t\n\t/**\n\t * Keep the scope unstable until release is called\n\t * @param reason\n\t */\n\twait( reason ) {\n\t\t//console.log(\"wait\", reason);\n\t\tthis._stable && !this.__locks.all && this.emit(\"unstable\", this);\n\t\tthis._stable = false;\n\t\tthis.__locks.all++;\n\t\tif ( reason ) {\n\t\t\tthis.__locks[reason] = this.__locks[reason] || 0;\n\t\t\tthis.__locks[reason]++;\n\t\t}\n\t}\n\t\n\t/**\n\t * Stabilize the scope if no more locks remain (wait fn)\n\t * @param reason\n\t */\n\trelease( reason ) {\n\t\t\n\t\tif ( reason ) {\n\t\t\tif ( this.__locks[reason] == 0 )\n\t\t\t\tconsole.error(\"Release more than locking !\", reason);\n\t\t\tthis.__locks[reason] = this.__locks[reason] || 0;\n\t\t\tthis.__locks[reason]--;\n\t\t}\n\t\tif ( !reason && this.__locks.all == 0 )\n\t\t\tconsole.error(\"Release more than locking !\");\n\t\t\n\t\tthis.__locks.all--;\n\t\tif ( !this.__locks.all ) {\n\t\t\tif ( this._.stabilizerTM )\n\t\t\t\treturn;\n\t\t\tthis._.stabilizerTM && clearTimeout(this._.stabilizerTM);\n\t\t\t\n\t\t\tthis._.stabilizerTM = setTimeout(\n\t\t\t\te => {\n\t\t\t\t\tthis._.stabilizerTM = null;\n\t\t\t\t\tif ( this.__locks.all )\n\t\t\t\t\t\treturn;\n\t\t\t\t\t\n\t\t\t\t\tthis._.propagTM && clearTimeout(this._.propagTM);\n\t\t\t\t\tthis._rev++;\n\t\t\t\t\tthis._stable = true;\n\t\t\t\t\tthis.emit(\"stable\", this);\n\t\t\t\t\t\n\t\t\t\t\t!this.dead && this._propag();// stability can induce destroy\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t\t\n\t}\n\t\n\t/**\n\t * Propag stores updates basing theirs last updates\n\t */\n\tpropag() {\n\t\tthis._.propagTM && clearTimeout(this._.propagTM);\n\t\tthis._.propagTM = setTimeout(\n\t\t\te => {\n\t\t\t\tthis._.propagTM = null;\n\t\t\t\tthis._propag()\n\t\t\t}, 2\n\t\t);\n\t}\n\t\n\t_propag() {\n\t\tif ( this._.followers.length )\n\t\t\tthis._.followers.forEach(( { 0: obj, 1: key, 2: as, 3: lastRevs, 3: remaps } ) => {\n\t\t\t\tlet data = this.getUpdates(lastRevs);\n\t\t\t\tif ( !data ) return;\n\t\t\t\tif ( typeof obj != \"function\" ) {\n\t\t\t\t\t//console.log(\"setState \",obj, Object.keys(data))\n\t\t\t\t\tif ( as ) obj.setState({ [as]: data });\n\t\t\t\t\telse obj.setState(data);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tobj(data, lastRevs && { ...lastRevs } || \"no revs\");\n\t\t\t\t}\n\t\t\t\t// lastRevs &&\n\t\t\t\t// key.forEach(id => (lastRevs[id] = this.stores[id] &&\n\t\t\t\t// this.stores[id]._rev || 0));\n\t\t\t});\n\t\tthis.emit(\"update\", this.getUpdates());\n\t}\n\t\n\t/**\n\t * is stable\n\t * @returns bool\n\t */\n\tisStable() {\n\t\treturn this._stable;\n\t}\n\t\n\t/**\n\t * is stable tree\n\t * @returns bool\n\t */\n\tisStableTree() {\n\t\treturn !this._.unStableChilds;\n\t}\n\t\n\t/**\n\t * Register children\n\t * @param scope\n\t * @private\n\t */\n\t_addChild( scope ) {\n\t\tthis._.childScopes.push(scope);\n\t\tthis._.seenChilds++;\n\t\tlet lists     = {\n\t\t\t    'stable'      : s => {\n\t\t\t\t    this._.unStableChilds--;\n\t\t\t\t    if ( !this._.unStableChilds )\n\t\t\t\t\t    this.emit(\"stableTree\", this)\n\t\t\t    },\n\t\t\t    'unstable'    : s => {\n\t\t\t\t    this._.unStableChilds++;\n\t\t\t\t    if ( 1 == this._.unStableChilds )\n\t\t\t\t\t    this.emit(\"unstableTree\", this)\n\t\t\t    },\n\t\t\t    'stableTree'  : s => {\n\t\t\t\t    this._.unStableChilds--;\n\t\t\t\t    if ( !this._.unStableChilds )\n\t\t\t\t\t    this.emit(\"stableTree\", this)\n\t\t\t    },\n\t\t\t    'unstableTree': s => {\n\t\t\t\t    this._.unStableChilds++;\n\t\t\t\t    if ( 1 == this._.unStableChilds )\n\t\t\t\t\t    this.emit(\"unstableTree\", this)\n\t\t\t    },\n\t\t\t    'destroy'     : ctx => {\n\t\t\t\t    if ( ctx._.unStableChilds )\n\t\t\t\t\t    this._.unStableChilds--;\n\t\t\t\t    if ( !ctx.isStable() )\n\t\t\t\t\t    this._.unStableChilds--;\n\t\t\t\t\n\t\t\t\t    if ( !this._.unStableChilds )\n\t\t\t\t\t    this.emit(\"stableTree\", this)\n\t\t\t    }\n\t\t    },\n\t\t    wasStable = this._.unStableChilds;\n\t\t\n\t\t!scope.isStable() && this._.unStableChilds++;\n\t\tscope._.unStableChilds && this._.unStableChilds++;\n\t\tthis._.childScopesList.push(lists);\n\t\t\n\t\tif ( !wasStable && this._.unStableChilds )\n\t\t\tthis.emit(\"unstableTree\", this);\n\t\t\n\t\tscope.on(lists);\n\t}\n\t\n\t_rmChild( ctx ) {\n\t\tlet i         = this._.childScopes.indexOf(ctx),\n\t\t    wasStable = this._.unStableChilds;\n\t\tif ( i != -1 ) {\n\t\t\tthis._.childScopes.splice(i, 1);\n\t\t\t!ctx.isStable() && this._.unStableChilds--;\n\t\t\tctx._.unStableChilds && this._.unStableChilds--;\n\t\t\tctx.un(this._.childScopesList.splice(i, 1)[0]);\n\t\t\tif ( wasStable && !this._.unStableChilds )\n\t\t\t\tthis.emit(\"stableTree\")\n\t\t}\n\t}\n\t\n\tretain( reason ) {\n\t\tthis.__retains.all++;\n\t\t//console.log(\"retain\", this._id, reason);\n\t\tif ( reason ) {\n\t\t\tthis.__retains[reason] = this.__retains[reason] || 0;\n\t\t\tthis.__retains[reason]++;\n\t\t}\n\t}\n\t\n\tdispose( reason ) {\n\t\t//console.log(\"dispose\", this._id, reason);\n\t\tif ( reason ) {\n\t\t\tif ( !this.__retains[reason] )\n\t\t\t\tthrow new Error(\"Dispose more than retaining : \" + reason);\n\t\t\tthis.__retains[reason]--;\n\t\t}\n\t\t\n\t\tif ( !this.__retains.all )\n\t\t\tthrow new Error(\"Dispose more than retaining !\");\n\t\t\n\t\tthis.__retains.all--;\n\t\t\n\t\tif ( !this.__retains.all ) {\n\t\t\t//console.log(\"dispose do destroy \", this._id, this._persistenceTm);\n\t\t\tif ( this._.persistenceTm ) {\n\t\t\t\tthis._.destroyTM && clearTimeout(this._.destroyTM);\n\t\t\t\tthis._.destroyTM = setTimeout(\n\t\t\t\t\te => {\n\t\t\t\t\t\tthis.then(s => {\n\t\t\t\t\t\t\t!this.__retains.all && !this.dead && this.destroy()\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\t\t\t\t\tthis._.persistenceTm\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.then(s =>\n\t\t\t\t\t          (!this.__retains.all && !this.dead && this.destroy())\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * order destroy of local stores\n\t */\n\tdestroy() {\n\t\tlet ctx = this._._scope;\n\t\t[...this._.childScopes].map(scope => scope.destroy())\n\t\tfor ( let key in ctx )\n\t\t\tif ( !is.fn(ctx[key]) ) {\n\t\t\t\tif ( key == \"$parent\" ) continue;\n\t\t\t\t!ctx[key]._autoDestroy && ctx[key].dispose(\"scoped\");\n\t\t\t}\n\t\tthis._.stabilizerTM && clearTimeout(this._.stabilizerTM);\n\t\tthis._.propagTM && clearTimeout(this._.propagTM);\n\t\tObject.keys(\n\t\t\tthis._._listening\n\t\t).forEach(\n\t\t\tid => ((id !== \"$parent\") && this._._scope[id].removeListener(this._._listening[id]))\n\t\t);\n\t\twhile ( this._._mixedList.length ) {\n\t\t\tthis._._mixed[0].removeListener(this._._mixedList.shift());\n\t\t\tthis._._mixed.shift().dispose(\"mixedTo\");\n\t\t}\n\t\t[...this._.followers].map(follower => this.unBind(...follower));\n\t\tif ( this._._parentList ) {\n\t\t\tthis.parent._rmChild(this);\n\t\t\tthis.parent.removeListener(this._._parentList);\n\t\t\tthis.parent.dispose(\"isMyParent\");\n\t\t\tthis._._parentList = null;\n\t\t}\n\t\tthis.dead = true;\n\t\tdelete allScopes[this._id];\n\t\tthis.emit(\"destroy\", this);\n\t\t\n\t\t\n\t}\n}\n\n\nScope.isScope = function ( obj ) {\n\treturn obj instanceof Scope\n};\n\nScope.isScopeClass = function ( obj ) {\n\treturn Scope.isPrototypeOf(obj) || obj === Scope\n};\nexport default Scope;","/*\n *   The MIT License (MIT)\n *   Copyright (c) 2019. Wise Wild Web\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy\n *   of this software and associated documentation files (the \"Software\"), to deal\n *   in the Software without restriction, including without limitation the rights\n *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *   copies of the Software, and to permit persons to whom the Software is\n *   furnished to do so, subject to the following conditions:\n *\n *   The above copyright notice and this permission notice shall be included in all\n *   copies or substantial portions of the Software.\n *\n *   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *   SOFTWARE.\n *\n *   @author : Nathanael Braun\n *   @contact : n8tz.js@gmail.com\n */\n\nlet $global = (typeof window !== 'undefined') ? window : global,\n    Scope   = require('./Scope').default,\n    Store   = require('./Store').default;\n\nconst RS = $global.___rescope || {};\n\nfunction scopeRef( map, key ) {\n\tmap[key] = new Scope.scopeRef(map[key]);\n\treturn map;\n};\nif ( $global.___rescope ) {\n\tconsole.warn(\"ReScope is defined multiple times !! \\nCheck you're packaging\")\n\tScope    = RS.Scope;\n\tStore    = RS.Store;\n\tscopeRef = RS.scopeRef;\n}\nelse {\n\t$global.___rescope = RS;\n\tScope.Store        = Store;\n}\nexport {Scope, Store, scopeRef};\nexport default { Scope, Store, scopeRef };","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","/*\n *   The MIT License (MIT)\n *   Copyright (c) 2019. Wise Wild Web\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy\n *   of this software and associated documentation files (the \"Software\"), to deal\n *   in the Software without restriction, including without limitation the rights\n *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *   copies of the Software, and to permit persons to whom the Software is\n *   furnished to do so, subject to the following conditions:\n *\n *   The above copyright notice and this permission notice shall be included in all\n *   copies or substantial portions of the Software.\n *\n *   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *   SOFTWARE.\n *\n *   @author : Nathanael Braun\n *   @contact : n8tz.js@gmail.com\n */\n\nconst is                           = require('is'),\n      Scope                        = require('./Scope').default,\n      { keyWalknSet, keyWalknGet } = require('./utils/utils'),\n      EventEmitter                 = require('./utils/Emitter').default,\n      TaskSequencer                = require('./utils/TaskSequencer').default,\n      shortid                      = require('shortid'),\n      objProto                     = Object.getPrototypeOf({});\n\nclass Store extends EventEmitter {\n\t//static use                  = [];// overridable list of source stores\n\tstatic follow;// overridable list of store that will allow push if updated\n\tstatic require;\n\tstatic staticScope   = new Scope({}, { id: \"static\" });\n\tstatic state         = undefined;// default state\n\t/**\n\t * if retain goes to 0 :\n\t * false to not destroy,\n\t * 0 to sync auto destroy\n\t * Ms to autodestroy after tm ms if no retain has been called\n\t * @type {boolean|Int}\n\t */\n\tstatic persistenceTm = false;\n\t\n\t/**\n\t * Constructor, will build a rescope store\n\t *\n\t * (scope, {require,use,apply,state, data})\n\t * (scope)\n\t *\n\t * @param scope {object} scope where to find the other stores (default : static\n\t *     staticScope )\n\t * @param keys {Array} (passed to Store::map) Ex : [\"session\", \"otherNamedStore:key\",\n\t *     otherStore.as(\"otherKey\")]\n\t */\n\tconstructor() {\n\t\tsuper();\n\t\tlet argz         = [...arguments],\n\t\t    _static      = this.constructor,\n\t\t    scope        = argz[0] instanceof Scope\n\t\t                   ? argz.shift()\n\t\t                   : _static.scope ? Scope.getScope(_static.scope)\n\t\t                                   : is.string(argz[0])\n\t\t                                     ? Scope.getScope(argz.shift())\n\t\t                                     : _static.staticScope,\n\t\t    cfg          = argz[0] && !is.array(argz[0]) && !is.string(argz[0])\n\t\t                   ? argz.shift()\n\t\t                   : {},\n\t\t    taskQueue    = is.array(argz[0]) ? argz.shift() : null,\n\t\t    name         = cfg.name || _static.name,\n\t\t    watchs       = cfg.use || [],\n\t\t    apply        = cfg.apply || null,\n\t\t    initialState = _static.state || _static.initialState || _static.defaultState;\n\t\t\n\t\tthis._uid = cfg._uid || shortid.generate();\n\t\t\n\t\tthis.__retains    = { all: 0 };\n\t\tthis.__locks      = { all: 0 };\n\t\tthis._onStabilize = [];\n\t\t\n\t\t// autoDestroyTm\n\t\tthis._autoDestroy   = !!this._persistenceTm;\n\t\tthis._persistenceTm = cfg.persistenceTm || _static.persistenceTm || (cfg.autoDestroy || _static.autoDestroy) && 5;\n\t\tthis._cfg           = cfg;\n\t\t\n\t\tif ( cfg && cfg.on ) {\n\t\t\tthis.on(cfg.on);\n\t\t}\n\t\t\n\t\tthis.name = name;\n\t\t\n\t\tif ( scope.stores ) {\n\t\t\tthis.scopeObj = scope;\n\t\t\tthis.scope    = scope.stores;\n\t\t}\n\t\telse {\n\t\t\tthis.scopeObj = new Scope(scope);\n\t\t\tthis.scope    = scope.stores;\n\t\t}\n\t\t\n\t\t// standardized scope access\n\t\tthis.$scope    = this.scopeObj;\n\t\tthis.$stores   = this.scopeObj.stores;\n\t\tthis.$actions  = this.scopeObj.actions;\n\t\tthis.$dispatch = this.scopeObj.dispatch.bind(this.scopeObj);\n\t\t\n\t\tthis._rev     = this.constructor._rev || 0;\n\t\tthis._revs    = {};\n\t\tthis.stores   = {};\n\t\tthis._require = [];\n\t\tthis._sources = [name];\n\t\t\n\t\t// register source stores\n\t\tif ( is.array(_static.use) ) {\n\t\t\tthis._use = [...watchs, ...(_static.use || []).map(\n\t\t\t\tkey => {\n\t\t\t\t\tlet ref = key.match(/^(\\!?)([^\\:]*)(?:\\:(.*))?$/);\n\t\t\t\t\tif ( ref[1] ) {\n\t\t\t\t\t\tlet ref2 = ref[2].split('.');\n\t\t\t\t\t\tthis._require.push(ref[3] || ref2[ref2.length - 1]);// require check value of the aliased\n\t\t\t\t\t                                                        // imported value\n\t\t\t\t\t\treturn key.substr(1);\n\t\t\t\t\t}\n\t\t\t\t\treturn key;\n\t\t\t\t}\n\t\t\t)];\n\t\t}\n\t\telse {\n\t\t\tthis._use = [...watchs, ...(\n\t\t\t\t_static.use ? Object.keys(_static.use)\n\t\t\t\t                    .map(\n\t\t\t\t\t                    key => {\n\t\t\t\t\t\t                    let ref = key.match(/^(\\!?)(.*)$/);\n\t\t\t\t\t\t                    ref[1] && this._require.push(_static.use[key]);\n\t\t\t\t\t\t                    return ref[2] + ((_static.use[key] === true)\n\t\t\t\t\t\t                                     ? ''\n\t\t\t\t\t\t                                     : ':' + _static.use[key]);\n\t\t\t\t\t                    }\n\t\t\t\t                    ) : []\n\t\t\t)];\n\t\t}\n\t\t\n\t\tif ( _static.require )\n\t\t\tthis._require.push(..._static.require);\n\t\tif ( cfg.require )\n\t\t\tthis._require.push(...cfg.require);\n\t\t\n\t\tthis._followers = [];\n\t\tthis._changesSW = initialState || {};\n\t\tthis.state      = initialState && {};\n\t\t\n\t\tif ( apply )\n\t\t\tthis.apply = apply;\n\t\t\n\t\t/**\n\t\t * Initial state isn't fully initialized ( childs constructors can set it )\n\t\t * Scope based instance have taskQueue to delay init synchronously, if not\n\t\t * present we use setTimeout\n\t\t */\n\t\tif ( taskQueue ) {\n\t\t\ttaskQueue.push(this._afterConstructor.bind(this))\n\t\t}\n\t\telse\n\t\t\tsetTimeout(this._afterConstructor.bind(this))\n\t}\n\t\n\t/**\n\t * Get the incoming state ( for immediate state relative actions )\n\t * @returns {{}|*}\n\t */\n\tget nextState() {\n\t\treturn this._nextState || this.state;\n\t}\n\t\n\t_afterConstructor() {\n\t\tlet cfg          = this._cfg,\n\t\t    _static      = this.constructor,\n\t\t    snapshot     = this.restore(undefined, true),\n\t\t    initialState = this.state,\n\t\t    initialData  = this.data,\n\t\t    applied;\n\t\t{\n\t\t\t\n\t\t\tif ( initialData )\n\t\t\t\tthis.data = initialData;\n\t\t\telse if ( _static.data !== undefined )\n\t\t\t\tthis.data = { ..._static.data };\n\t\t\telse if ( cfg.hasOwnProperty(\"data\") )\n\t\t\t\tthis.data = cfg.data;\n\t\t\t\n\t\t\tif ( cfg.hasOwnProperty(\"state\") && cfg.state !== undefined )\n\t\t\t\tinitialState = { ...initialState, ...cfg.state };\n\t\t\t\n\t\t\tif ( this.data === undefined ) {\n\t\t\t\tif ( initialState || this._use.length ) {// sync apply\n\t\t\t\t\tthis._nextState = this._changesSW = {\n\t\t\t\t\t\t...this._changesSW,\n\t\t\t\t\t\t...(initialState || {}),\n\t\t\t\t\t\t...this.$scope.map(this, this._use)\n\t\t\t\t\t};\n\t\t\t\t\tthis.state      = {};\n\t\t\t\t\tif ( this.shouldApply(this._nextState) && this.data === undefined ) {\n\t\t\t\t\t\tthis.data       = this.apply(this.data, this._nextState, this._changesSW);\n\t\t\t\t\t\tapplied         = true;\n\t\t\t\t\t\tthis.state      = this._changesSW;\n\t\t\t\t\t\tthis._nextState = this._changesSW = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tapplied         = true;\n\t\t\t\tthis.state      = {// assume this state is sync with initial data\n\t\t\t\t\t...this._changesSW,\n\t\t\t\t\t...(initialState || {}),\n\t\t\t\t\t...this.$scope.map(this, this._use)\n\t\t\t\t};\n\t\t\t\tthis._nextState = this._changesSW = null;\n\t\t\t}\n\t\t}\n\t\tif ( (this.data !== undefined || applied) && !this.__locks.all ) {\n\t\t\tthis._stable = true;\n\t\t\tthis._rev++;\n\t\t}\n\t\telse {\n\t\t\tthis._stable = false;\n\t\t\tif ( !_static.managed && !this.state && (!this._use || !this._use.length) ) {\n\t\t\t\tconsole.warn(\"ReScope store '\", this.name, \"' have no initial data, state or use. It can't stabilize...\");\n\t\t\t}\n\t\t}\n\t\t!this._stable && this.emit('unstable', this.state);\n\t\t\n\t}\n\t\n\t/**\n\t * Overridable method to know if a data change should be propag to the listening\n\t * stores & components\n\t */\n\tshouldPropag( nDatas ) {\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Overridable method to choose if this store should be serialized,\n\t * If not it will be applied normally when restoring\n\t * @returns {boolean}\n\t */\n\tshouldSerialize() {\n\t\treturn true;\n\t}\n\t\n\thasDataChange( nDatas ) {\n\t\tlet _static = this.constructor, r,\n\t\t    cDatas  = this.data;\n\t\tr           = !cDatas && nDatas || cDatas !== nDatas;\n\t\t!r && cDatas && Object.keys(cDatas).forEach(\n\t\t\t( key ) => {\n\t\t\t\tr = r || (nDatas\n\t\t\t\t          ? cDatas[key] !== nDatas[key]\n\t\t\t\t          : cDatas && cDatas[key])\n\t\t\t}\n\t\t);\n\t\t!r && nDatas && Object.keys(nDatas).forEach(\n\t\t\t( key ) => {\n\t\t\t\tr = r || (nDatas\n\t\t\t\t          ? cDatas[key] !== nDatas[key]\n\t\t\t\t          : cDatas && cDatas[key])\n\t\t\t}\n\t\t);\n\t\treturn r;\n\t}\n\t\n\t/**\n\t * Overridable method to know if a state change should be applied\n\t */\n\tshouldApply( state = this.state ) {\n\t\tlet _static = this.constructor;\n\t\t\n\t\treturn (\n\t\t\t!!this.isComplete(state)\n\t\t) && (is.array(_static.follow)\n\t\t      ? _static.follow\n\t\t               .reduce(( r, i ) => (r || state && state[i]), false)\n\t\t      : _static.follow\n\t\t        ? Object.keys(_static.follow)\n\t\t                .reduce(( r, i ) => (\n\t\t\t                r\n\t\t\t                || state && is.fn(_static.follow[i]) && _static.follow[i].call(this, state[i])\n\t\t\t                || _static.follow[i] && state[i] !== this.state[i]\n\t\t                ), false) : true\n\t\t);\n\t}\n\t\n\t/**\n\t * Overridable applier / remapper\n\t * If state or lastPublicState are simple hash maps apply will return {...data,\n\t * ...state} if not it will return the last private state\n\t * @param data\n\t * @param state\n\t * @returns {*}\n\t */\n\tapply( data, state, changes ) {\n\t\treturn state;\n\t}\n\t\n\t/**\n\t * Debounce this store propagation ( & reducing )\n\t * @param cb\n\t */\n\tstabilize( cb ) {\n\t\tcb && this.once('stable', cb);\n\t\t\n\t\tif ( this._stabilizer )\n\t\t\treturn;\n\t\tthis._stable && this.emit('unstable', this.state, this.data);\n\t\tthis._stable = false;\n\t\t\n\t\tthis._stabilizer = TaskSequencer.pushTask(this, 'pushState');\n\t}\n\t\n\t/**\n\t * Walk n get\n\t * @param path\n\t * @param i\n\t * @param obj\n\t * @returns {*|{}}\n\t */\n\tretrieve( path, i = 0, obj = this.data ) {\n\t\tpath = is.string(path) ? path.split('.') : path;\n\t\treturn !obj || !path || !path.length\n\t\t       ? obj\n\t\t       : path.length == i + 1\n\t\t         ? obj[path[i]]\n\t\t         : this.retrieve(path, i + 1, obj[path[i]]);\n\t}\n\t\n\tdispatch( action, ...argz ) {\n\t\tthis.scopeObj.dispatch(action, ...argz);\n\t}\n\t\n\ttrigger( action, ...argz ) {\n\t\tlet { actions } = this.constructor;\n\t\tif ( actions && actions[action] ) {\n\t\t\tlet ns = actions[action].call(this, ...argz);\n\t\t\tif ( is.function(ns) )\n\t\t\t\tns = ns(this.nextState);\n\t\t\tns && this.setState(ns);\n\t\t}\n\t}\n\t\n\t/**\n\t * Set & Push the result data to followers if stable\n\t * @param cb\n\t */\n\tpush( data, force, cb ) {\n\t\tcb    = force === true ? cb : force;\n\t\tforce = force === true;\n\t\tif ( !force &&\n\t\t\t(\n\t\t\t\t!this.hasDataChange(data)\n\t\t\t)\n\t\t) {\n\t\t\tcb && cb();\n\t\t\tif ( !this.__locks.all ) {\n\t\t\t\tlet stable   = this._stable;\n\t\t\t\tthis._stable = true;\n\t\t\t\t!stable && this.emit('stable', this.state, this.data);\n\t\t\t\t//this._stabilizer = null;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tthis.data = data;\n\t\tthis.wait();\n\t\tthis.release(cb);\n\t\t\n\t}\n\t\n\t/**\n\t * Call the apply fn using the current accumulated state update then, push the\n\t * resulting data if stable\n\t * @param forcedState\n\t */\n\tpushState( forcedState ) {\n\t\tthis._stabilizer = null;\n\t\tif ( !forcedState && !this._changesSW && this.data )\n\t\t\treturn;\n\t\t\n\t\tlet nextState = forcedState || this._nextState || this.state,\n\t\t    nextData;\n\t\tObject.keys(nextState).forEach(\n\t\t\tkey => (nextState[key] === undefined && (delete nextState[key]))\n\t\t);\n\t\tnextData = this.apply(this.data, nextState, this._changesSW);\n\t\t\n\t\tthis.state      = nextState;\n\t\tthis._nextState = null;\n\t\tthis._changesSW = null;\n\t\t\n\t\tif ( !forcedState &&\n\t\t\t(\n\t\t\t\t!this.hasDataChange(nextData)\n\t\t\t)\n\t\t) {\n\t\t\tif ( !this.__locks.all ) {\n\t\t\t\tlet stable   = this._stable;\n\t\t\t\tthis._stable = true;\n\t\t\t\t!stable && this.emit('stable', this.state, this.data);\n\t\t\t\tthis._stabilizer = null;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tthis.data = nextData;\n\t\tthis.wait();\n\t\tthis.release();\n\t}\n\t\n\t/**\n\t * Add 'pState' to the current accumulated state updates\n\t * & wait source stores stabilization before pushing these state updates\n\t * @param pState\n\t * @param cb\n\t */\n\tsetState( pState, cb, sync ) {\n\t\tlet change,\n\t\t    changes   = this._changesSW = this._changesSW || {},\n\t\t    nextState = this._nextState = this._nextState || { ...this.state },\n\t\t    key;\n\t\tfor ( key in pState )\n\t\t\tif ( !this.state\n\t\t\t\t|| changes.hasOwnProperty(key)// todo\n\t\t\t\t&& (\n\t\t\t\t\tpState[key] !== changes[key]\n\t\t\t\t) || pState.hasOwnProperty(key)\n\t\t\t\t&& (\n\t\t\t\t\tpState[key] !== this.state[key]\n\t\t\t\t) ) {\n\t\t\t\tchange         = true;\n\t\t\t\tnextState[key] = changes[key] = pState[key];\n\t\t\t}\n\t\t\n\t\tif ( !this.shouldApply(nextState) ) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif ( sync ) {\n\t\t\tthis.pushState();\n\t\t\tcb && cb();\n\t\t}\n\t\telse {\n\t\t\tif ( change ) {\n\t\t\t\tthis.stabilize(cb);\n\t\t\t}\n\t\t\telse cb && cb();\n\t\t}\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Update the current state & push it\n\t * @param pState\n\t * @param cb\n\t */\n\tsetStateSync( pState ) {\n\t\tlet i       = 0, change,\n\t\t    changes = this._changesSW = this._changesSW || {};\n\t\tfor ( let k in pState )\n\t\t\tif ( !this.state || pState.hasOwnProperty(k)\n\t\t\t\t&& (\n\t\t\t\t\tpState[k] !== this.state[k]\n\t\t\t\t\t//||\n\t\t\t\t\t//(this.state[k] && pState[k] && (pState[k]._rev != this._revs[k]))// rev/hash update\n\t\t\t\t) ) {\n\t\t\t\tchange        = true;\n\t\t\t\tthis._revs[k] = pState[k] && pState[k]._rev || true;\n\t\t\t\tchanges[k]    = pState[k];\n\t\t\t}\n\t\tthis.shouldApply({ ...(this.state || {}), ...changes }) && this.pushState();\n\t\treturn this.data;\n\t}\n\t\n\t/**\n\t * get a store-key pair for Store::map\n\t * @param {string} name\n\t * @returns {{store: Store, name: *}}\n\t */\n\tas( name ) {\n\t\treturn { store: this, name };\n\t}\n\t\n\ton( lists ) {\n\t\tif ( !is.string(lists) && lists )\n\t\t\tObject.keys(lists).forEach(k => super.on(k, lists[k]));\n\t\telse super.on(...arguments);\n\t}\n\t\n\tremoveListener( lists ) {\n\t\tif ( !is.string(lists) && lists )\n\t\t\tObject.keys(lists).forEach(k => super.removeListener(k, lists[k]));\n\t\telse super.removeListener(...arguments);\n\t}\n\t\n\t/**\n\t * is complete (all requiered keys are here)\n\t * @returns bool\n\t */\n\tisComplete( state = this.state ) {\n\t\treturn (\n\t\t\t!this._require\n\t\t\t|| !this._require.length\n\t\t\t|| state && this._require.reduce(\n\t\t\t\t( r, key ) => (r && state[key]),\n\t\t\t\ttrue\n\t\t\t)\n\t\t);\n\t}\n\t\n\t/**\n\t * is stable\n\t * @returns bool\n\t */\n\tisStable() {\n\t\treturn this._stable;\n\t}\n\t\n\t/**\n\t * Serialize state & data with sources refs\n\t * @returns bool\n\t */\n\tserialize( cfg = {}, output = {} ) {\n\t\t\n\t\tlet sId        = cfg.parentAlias || this.scopeObj._id,\n\t\t    refsCount  = 0,\n\t\t    refs       =\n\t\t\t    !cfg.norefs && is.array(this._use) && this._use.reduce(\n\t\t\t    ( map, key ) => {\n\t\t\t\t    let ref   = this.$scope.parseRef(key),\n\t\t\t\t        store = this.$stores[ref.storeId];\n\t\t\t\t    if ( store && Store.isStore(store) && !store.scopeObj._.isLocalId )\n\t\t\t\t\t    refsCount++, map[ref.alias] = ref.path;\n\t\t\t\t\n\t\t\t\t    return map;\n\t\t\t    }, {}\n\t\t\t    ),\n\t\t    state      = this.state || {},\n\t\t    persistent = this.shouldSerialize();\n\t\t\n\t\tif ( !persistent ) {\n\t\t\tkeyWalknSet(\n\t\t\t\toutput,\n\t\t\t\t(sId + '/' + this.name),\n\t\t\t\t{\n\t\t\t\t\tdataRefs: cfg.dataRefs,\n\t\t\t\t\trefs\n\t\t\t\t}\n\t\t\t);\n\t\t\treturn output;\n\t\t}\n\t\t\n\t\tlet\n\t\t\tstateKeys   = Object.keys(state) || [],\n\t\t\tstateRefs   = stateKeys.map(k => state[k]),\n\t\t\tinRefsCount = 0,\n\t\t\tdataRefs    = cfg.dataRefs || {},\n\t\t\tinRefs      =\n\t\t\t\t!cfg.norefs && this.data && (Object.keys(this.data).reduce(\n\t\t\t\t( map, key ) => {\n\t\t\t\t\tlet ref = stateRefs.indexOf(this.data[key])\n\t\t\t\t\tif ( ref != -1 )\n\t\t\t\t\t\tinRefsCount++, map[key] = stateKeys[ref];\n\t\t\t\t\treturn map;\n\t\t\t\t}, {}\n\t\t\t\t)),\n\t\t\tsnap        = {\n\t\t\t\tdataRefs: cfg.dataRefs,\n\t\t\t\tstate   : state &&\n\t\t\t\t\t(\n\t\t\t\t\t\tcfg.norefs\n\t\t\t\t\t\t? { ...state }\n\t\t\t\t\t\t: Object.keys(state).reduce(( h, k ) => (!refs[k] && (h[k] = state[k]), h), {})\n\t\t\t\t\t),\n\t\t\t\tdata    : (\n\t\t\t\t\t\tthis.data &&\n\t\t\t\t\t\tthis.data.__proto__ === objProto ?\n\t\t\t\t\t\tObject\n\t\t\t\t\t\t\t.keys(this.data)\n\t\t\t\t\t\t\t.reduce(\n\t\t\t\t\t\t\t\t( h, k ) => {\n\t\t\t\t\t\t\t\t\tif ( !inRefs[k] && !dataRefs[k] ) {\n\t\t\t\t\t\t\t\t\t\th[k] = this.data[k];\n\t\t\t\t\t\t\t\t\t\tinRefsCount++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn h\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{}\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t                                 :\n\t\t\t\t\t\t(is.bool(this.data)\n\t\t\t\t\t\t\t|| is.number(this.data)\n\t\t\t\t\t\t\t|| is.string(this.data)) && this.data\n\t\t\t\t\t)\n\t\t\t\t\t|| undefined\n\t\t\t\t\n\t\t\t};\n\t\t\n\t\trefs && refsCount && (snap.refs = refs);\n\t\tinRefs && inRefsCount && (\n\t\t\tsnap.inRefs = inRefs);\n\t\t\n\t\t\n\t\tkeyWalknSet(\n\t\t\toutput,\n\t\t\t(sId + '/' + this.name),\n\t\t\tsnap\n\t\t);\n\t\treturn output;\n\t}\n\t\n\t/**\n\t * restore state & data\n\t * @returns bool\n\t */\n\trestore( snapshot, immediate ) {\n\t\tsnapshot = snapshot\n\t\t\t&& keyWalknGet(snapshot, this.scopeObj._id + '/' + this.name)\n\t\t\t|| this.$scope.takeSnapshotByKey(this.scopeObj._id + '/' + this.name);\n\t\t\n\t\tif ( !snapshot )\n\t\t\treturn;\n\t\t\n\t\tif ( snapshot ) {\n\t\t\t\n\t\t\tif ( !this.isStable() && !immediate )\n\t\t\t\tthis.then(() => this.restore(snapshot));\n\t\t\t\n\t\t\tthis.state = { ...snapshot.state };\n\t\t\tsnapshot.refs && Object.keys(snapshot.refs).forEach(\n\t\t\t\t( key ) => {//todo\n\t\t\t\t\tthis.state[key] = this.$scope.retrieve(snapshot.refs[key]);\n\t\t\t\t}\n\t\t\t)\n\t\t\t\n\t\t\t\n\t\t\tif ( snapshot.inRefs === true ) {\n\t\t\t\tthis.data = { ...this.state };\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.data = snapshot.data;\n\t\t\t\tsnapshot.inRefs && Object.keys(snapshot.inRefs).forEach(\n\t\t\t\t\t( key ) => {//todo\n\t\t\t\t\t\tthis.data[key] = this.state[snapshot.inRefs[key]];\n\t\t\t\t\t\t//else\n\t\t\t\t\t\t//    console.warn('not found : ', key, snap && snap.refs[ key ])\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tif ( snapshot.dataRefs ) {\n\t\t\t\tthis.data = this.data || {};\n\t\t\t\tObject.keys(snapshot.dataRefs).forEach(\n\t\t\t\t\t( key ) => {//todo\n\t\t\t\t\t\tthis.$scope.restoreRefPath(snapshot.dataRefs[key]);\n\t\t\t\t\t\tthis.data[key] = this.$scope.retrieve(snapshot.dataRefs[key]);\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\t\n\t/**\n\t * Bind this store changes to the given component-key\n\t * @param obj {React.Component|Store|function)\n\t * @param key {string} optional key where to map the public state\n\t */\n\tbind( obj, key, setInitial = true, path ) {\n\t\tthis._followers.push([obj, key, path]);\n\t\tif ( setInitial && this.data && this._stable ) {\n\t\t\tlet data = path ? this.retrieve(path) : this.data;\n\t\t\tif ( typeof obj != \"function\" ) {\n\t\t\t\tif ( key ) obj.setState({ [key]: data });\n\t\t\t\telse obj.setState(data);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tobj(data);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Un bind this store off the given component-key\n\t * @param obj\n\t * @param key\n\t * @returns {Array.<*>}\n\t */\n\tunBind( obj, key, path ) {\n\t\tlet followers = this._followers,\n\t\t    i         = followers && followers.length;\n\t\twhile ( followers && i-- )\n\t\t\tif ( followers[i][0] === obj && followers[i][1] === key && followers[i][2] === path )\n\t\t\t\treturn followers.splice(i, 1);\n\t}\n\t\n\t/**\n\t * once('stable', cb)\n\t * @param obj {React.Component|Store|function)\n\t * @param key {string} optional key where to map the public state\n\t */\n\tthen( cb ) {\n\t\tif ( this._stable )\n\t\t\treturn cb(this.data);\n\t\tthis.once('stable', e => cb(this.data));\n\t}\n\t\n\t/**\n\t * Add a lock so the store will not propag it data untill release() is call\n\t * @param previous {Store|number|Array} @optional wf to wait, releases to wait or\n\t *     array of stuff to wait\n\t * @returns {this}\n\t */\n\twait( previous ) {\n\t\tif ( typeof previous == \"number\" )\n\t\t\treturn this.__locks.all += previous;\n\t\tif ( is.array(previous) )\n\t\t\treturn previous.map(this.wait.bind(this));\n\t\t\n\t\tthis._stable && this.emit('unstable', this.state, this.data);\n\t\tthis._stable = false;\n\t\tthis.__locks.all++;\n\t\t\n\t\tlet reason = is.string(previous) ? previous : null;\n\t\tif ( reason ) {\n\t\t\tthis.__locks[reason] = this.__locks[reason] || 0;\n\t\t\tthis.__locks[reason]++;\n\t\t}\n\t\tif ( previous && is.fn(previous.then) ) {\n\t\t\tprevious.then(this.release.bind(this, null));\n\t\t}\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Decrease locks for this store, if it reach 0 ,\n\t * it will be propagated to the followers,\n\t * then, all stuff passed to \"then\" call back will be exec / released\n\t * @param desync\n\t * @returns {*}\n\t */\n\trelease( reason, cb ) {\n\t\tlet _static = this.constructor, me = this;\n\t\tlet i       = 0, wasStable = this._stable;\n\t\t\n\t\tif ( is.fn(reason) ) {\n\t\t\tcb     = reason;\n\t\t\treason = null;\n\t\t}\n\t\t\n\t\tif ( reason ) {\n\t\t\tif ( this.__locks[reason] == 0 )\n\t\t\t\tconsole.error(\"Release more than locking !\", reason);\n\t\t\tthis.__locks[reason] = this.__locks[reason] || 0;\n\t\t\tthis.__locks[reason]--;\n\t\t}\n\t\t\n\t\tif ( !reason && this.__locks.all == 0 )\n\t\t\tconsole.error(\"Release more than locking !\");\n\t\t\n\t\tif ( !--this.__locks.all && this.isComplete() ) {\n\t\t\tlet propag   = this.shouldPropag(this.data);\n\t\t\tthis._stable = true;\n\t\t\tpropag && this._rev++;//\n\t\t\tif ( propag && this._followers.length )\n\t\t\t\tthis._followers.forEach(function propag( follower ) {\n\t\t\t\t\tlet data = follower[2] ? me.retrieve(follower[2]) : me.data;\n\t\t\t\t\t//if ( !data ) return;\n\t\t\t\t\t\n\t\t\t\t\tif ( typeof follower[0] == \"function\" ) {\n\t\t\t\t\t\tfollower[0](data);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t//cb && i++;\n\t\t\t\t\t\tfollower[0].setState(\n\t\t\t\t\t\t\t(follower[1]) ? { [follower[1]]: data }\n\t\t\t\t\t\t\t              : data\n\t\t\t\t\t\t\t//,\n\t\t\t\t\t\t\t//cb && (\n\t\t\t\t\t\t\t//    () => (!(--i) && cb())\n\t\t\t\t\t\t\t//)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t//else\n\t\t\t!wasStable && this.emit('stable', this.data);\n\t\t\tpropag && this.emit('update', this.data);\n\t\t\tcb && cb()\n\t\t}\n\t\telse cb && this.then(cb);\n\t\treturn this;\n\t}\n\t\n\tpropag( data ) {\n\t\tthis.emit('update', data);\n\t}\n\t\n\tretain( reason ) {\n\t\tthis.__retains.all++;\n\t\tif ( reason ) {\n\t\t\tthis.__retains[reason] = this.__retains[reason] || 0;\n\t\t\tthis.__retains[reason]++;\n\t\t}\n\t}\n\t\n\tdispose( reason ) {\n\t\t//console.warn(\"dispose\", reason, this.__retains);\n\t\tif ( reason ) {\n\t\t\tif ( !this.__retains[reason] ) {\n\t\t\t\tthrow new Error(\"RS : Dispose more than retaining on store '\" + this.name + \"' : \" + reason);\n\t\t\t}\n\t\t\t\n\t\t\tthis.__retains[reason]--;\n\t\t}\n\t\tif ( this.__retains.all == 0 ) {\n\t\t\tthrow new Error(\"RS : Dispose more than retaining on store \" + this.name);\n\t\t}\n\t\t\n\t\tthis.__retains.all--;\n\t\t\n\t\tif ( !this.__retains.all ) {\n\t\t\tif ( this._persistenceTm ) {\n\t\t\t\tthis._destroyTM && clearTimeout(this._destroyTM);\n\t\t\t\tthis._destroyTM = setTimeout(\n\t\t\t\t\te => {\n\t\t\t\t\t\tthis._destroyTM = null;\n\t\t\t\t\t\t//this.then(s => {\n\t\t\t\t\t\t!this.__retains.all && !this.dead && this.destroy()\n\t\t\t\t\t\t//});\n\t\t\t\t\t},\n\t\t\t\t\tthis._persistenceTm\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//this.then(s =>\n\t\t\t\t(!this.__retains.all && !this.dead && this.destroy())\n\t\t\t\t//);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdestroy() {\n\t\t//  console.log(\"destroy\", this._uid);\n\t\t\n\t\tif ( this._stabilizer ) {\n\t\t\tthis._stabilizer = null;\n\t\t\tclearTimeout(this._stabilizer);\n\t\t}\n\t\tthis.emit('destroy', this);\n\t\t\n\t\tif ( this._followers.length )\n\t\t\tthis._followers.forEach(\n\t\t\t\t( follower ) => {\n\t\t\t\t\tif ( typeof follower[0] !== \"function\" ) {\n\t\t\t\t\t\tif ( follower[0].stores )\n\t\t\t\t\t\t\tdelete follower[0].stores[follower[1]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\tthis._followers.length = 0;\n\t\tthis.constructor._rev  = this.rev;\n\t\tthis.dead              = true;\n\t\tthis._revs             = this.data = this.state = this.scope = null;\n\t\tthis.removeAllListeners();\n\t}\n}\n\n/**\n * get a static aliased reference of a store\n * @param {string} name\n * @returns {{store: Store, name: *}}\n */\nStore.as = function ( name ) {\n\treturn { store: this, name };\n}\n\n/**\n * @todo\n * Map all named stores in {keys} to the {object}'s state\n * Hook componentWillUnmount (for react comp) or destroy to unBind them automatically\n * @static\n * @param object {Object} target state aware object (React.Component|Store|...)\n * @param keys {Array} Ex : [\"session\", \"otherStaticNamedStore:key\",\n *     store.as('anotherKey')]\n */\nStore.map = function ( cStore, keys, scope, origin, setInitial = false ) {\n\tlet targetRevs     = cStore._revs || {};\n\tlet targetScope    = cStore.stores || (cStore.stores = {});\n\tlet initialOutputs = {};\n\tkeys               = is.array(keys) ? [...keys] : [keys];\n\t\n\t\n\tscope = scope || Store.staticScope;\n\t\n\tkeys = keys.filter(\n\t\t// @todo : use query refs\n\t\t// (store)(\\.store)*(\\[(\\*|(props)\\w+)+)\\])?(\\:alias)\n\t\t( key ) => {\n\t\t\tif ( !key ) {\n\t\t\t\tconsole.error(\"Not a mappable store item '\" + key + \"' in \" + origin + ' !!');\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tlet name,\n\t\t\t    alias,\n\t\t\t    path,\n\t\t\t    store, _key;\n\t\t\tif ( key.store && key.name ) {\n\t\t\t\talias = name = key.name;\n\t\t\t\tstore = key.store;\n\t\t\t}\n\t\t\telse if ( is.fn(key) ) {\n\t\t\t\tname  = alias = key.name || key.defaultName;\n\t\t\t\tstore = key;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_key  = key.match(/([^\\.\\:]+)((?:\\.[^\\.\\:]+)*)(?:\\:([^\\.\\:]+))?/);\n\t\t\t\tname  = _key[1];\n\t\t\t\tpath  = _key[2] && _key[2].substr(1);\n\t\t\t\tstore = scope.stores[_key[1]];\n\t\t\t\talias = _key[3] || path && path.match(/([^\\.]*)$/)[0] || _key[1];\n\t\t\t}\n\t\t\tif ( !store ) {\n\t\t\t\tlet i = [];\n\t\t\t\tfor ( let o in scope.stores )\n\t\t\t\t\ti.push(o)\n\t\t\t\tconsole.error(\"Not a mappable store item '\" + name + \"/\" + alias + \"' in \" + (cStore.name || cStore) + ' !!', store, _key, scope.stores, i);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ( Scope.isScopeClass(store) ) scope._mount(name);\n\t\t\tif ( Scope.isScope(store) ) {\n\t\t\t\tstore = scope._mount(key);\n\t\t\t}\n\t\t\telse if ( targetRevs[name] ) return false;// ignore dbl uses for now\n\t\t\t\n\t\t\t\n\t\t\tif ( is.fn(store) ) {\n\t\t\t\tscope._mount(name)\n\t\t\t\tscope.stores[name].bind(cStore, alias, setInitial, path);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstore.bind(cStore, alias, setInitial, path);\n\t\t\t}\n\t\t\t\n\t\t\t// give initial store weight basing sources\n\t\t\tscope.stores[name]._sources && cStore._sources.push(...scope.stores[name]._sources);\n\t\t\t\n\t\t\ttargetRevs[alias] = targetRevs[alias] || true;\n\t\t\t!targetScope[name] && (targetScope[name] = scope.stores[name]);\n\t\t\tif ( scope.stores[name].hasOwnProperty('data') )\n\t\t\t\tinitialOutputs[name] = scope.data[name];\n\t\t\treturn true;\n\t\t}\n\t);\n\t\n\t// ... @todo\n\tcStore.once('destroy', ( ...argz ) => {\n\t\tkeys.map(\n\t\t\t( key ) => {\n\t\t\t\tlet name,\n\t\t\t\t    alias, path,\n\t\t\t\t    store;\n\t\t\t\tif ( key.store && key.name ) {\n\t\t\t\t\talias = name = key.name;\n\t\t\t\t\tstore = key.store;\n\t\t\t\t}\n\t\t\t\telse if ( is.fn(key) ) {\n\t\t\t\t\tname  = alias = key.name || key.defaultName;\n\t\t\t\t\tstore = scope.stores[name];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tkey   = key.match(/([^\\.\\:]+)((?:\\.[^\\.\\:]+)*)(?:\\:([^\\.\\:]+))?/);\n\t\t\t\t\tname  = key[1];\n\t\t\t\t\tpath  = key[2] && key[2].substr(1);\n\t\t\t\t\tstore = scope.stores[key[1]];\n\t\t\t\t\talias = key[3] || path && path.match(/([^\\.]*)$/)[0] || key[1];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstore && !is.fn(store) && store.unBind(cStore, alias, path)\n\t\t\t}\n\t\t);\n\t})\n\t\n\treturn initialOutputs;\n};\n\n\nStore.isStore      = Scope.isStore = function ( obj ) {\n\treturn obj instanceof Store\n}\nStore.isStoreClass = Scope.isStoreClass = function ( obj ) {\n\treturn Store.isPrototypeOf(obj) || obj === Store\n}\n\nexport default Store;","/*\n *   The MIT License (MIT)\n *   Copyright (c) 2019. Wise Wild Web\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy\n *   of this software and associated documentation files (the \"Software\"), to deal\n *   in the Software without restriction, including without limitation the rights\n *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *   copies of the Software, and to permit persons to whom the Software is\n *   furnished to do so, subject to the following conditions:\n *\n *   The above copyright notice and this permission notice shall be included in all\n *   copies or substantial portions of the Software.\n *\n *   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *   SOFTWARE.\n *\n *   @author : Nathanael Braun\n *   @contact : n8tz.js@gmail.com\n */\n\n/**\n * Minimal push sequencer, apply stores specific task in the right order\n */\nlet taskQueue      = [],\n    curWeight      = 0,\n    maxWeight      = 0,\n    minWeight      = 0,\n    taskCount      = 0,\n    deSync         = false,\n    deSyncMaxTasks = 10,\n    task,\n    isRunning,\n    errorCatcher   = {\n\t    lastError: null,\n\t    dispatch : function ( error ) {\n\t\t    errorCatcher.disable();\n\t\t\n\t\t    if ( task && task[0].handleError ) {\n\t\t\t    task[0].handleError(error, task);\n\t\t    }\n\t\t    else if ( task )\n\t\t\t    console.error(\"ReScope : An apply task has failed !!\", task[1], \" on \", task[0].name || task[0].constructor.name)\n\t\t\n\t\t    isRunning = false;\n\t\t    task      = null;\n\t\t    runNow();\n\t    },\n\t    enable   : (typeof window !== 'undefined')\n\t               ? () => {\n\t\t\t    window.addEventListener('error', errorCatcher.dispatch)\n\t\t    } : () => {\n\t\t\t    process.on('uncaughtException', errorCatcher.dispatch);\n\t\t    },\n\t    disable  : (typeof window !== 'undefined')\n\t               ? () => {\n\t\t\t    window.removeEventListener('error', errorCatcher.dispatch)\n\t\t    } : () => {\n\t\t\t    process.removeListener('uncaughtException', errorCatcher.dispatch);\n\t\t    }\n    }\n;\n\nfunction runNow() {\n\tif ( !isRunning ) {\n\t\trun();\n\t}\n}\n\nfunction run() {\n\tlet from  = Date.now();\n\tisRunning = true;\n\terrorCatcher.enable();\n\twhile ( taskCount ) {\n\t\t\n\t\t// try for the current weight\n\t\twhile ( !(taskQueue[curWeight] && taskQueue[curWeight].length) )\n\t\t\tcurWeight++;\n\t\t\n\t\ttaskCount--;\n\t\ttask = taskQueue[curWeight].shift();\n\t\t//console.log(\"Task : \", task[1], \" on \", task[0].name);\n\t\ttry {\n\t\t\t!task[0].dead && task[0][task[1]](task[2]);\n\t\t} catch ( e ) {\n\t\t\treturn errorCatcher.dispatch(e);\n\t\t}\n\t}\n\ttask = undefined;\n\terrorCatcher.disable();\n\t\n\tisRunning = false;\n\tif ( taskCount ) {\n\t\tsetTimeout(runNow);\n\t}\n}\n\n//\n//index.setTaskDeSync = ( nb ) => {\n//    if ( nb === false )\n//        return deSync = false;\n//    else if ( nb === true ) {\n//        deSync         = true;\n//        deSyncMaxTasks = 10;\n//    }\n//    else (is.int(nb))\n//    {\n//        deSync         = true;\n//        deSyncMaxTasks = nb;\n//    }\n//};\n\nexport default {\n\tpushTask( obj, fn, argz ) {\n\t\t/**\n\t\t * The more a store have sources, the more it should be processed first\n\t\t * So leafs stores stay sync, and root stores receive merged state updates;\n\t\t * global state stay coherent\n\t\t *\n\t\t * This mean whatever the number of stores & the complexity of the deps,\n\t\t * updating a store state will update its synchrone child stores immediately\n\t\t *\n\t\t *\n\t\t * @type {*|number}\n\t\t */\n\t\tlet weight = obj._sources && obj._sources.length || 1,\n\t\t    stack  = taskQueue[weight] =\n\t\t\t    taskQueue[weight] || [];\n\t\t\n\t\tmaxWeight = Math.max(maxWeight, weight);\n\t\tcurWeight = Math.min(curWeight, weight);\n\t\ttaskCount++;\n\t\t\n\t\t//console.log(\"Push Task : \", fn, \" on \", obj.name, weight);\n\t\tstack.push([obj, fn, argz]);\n\t\tsetTimeout(runNow, 0);\n\t\treturn stack.length;\n\t}\n};","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n"],"sourceRoot":""}